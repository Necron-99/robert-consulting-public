name: Staging to Production Deployment Pipeline (Fallback)

# Fallback version that uses manual approval action instead of GitHub environments
# Use this if the environment-based approach doesn't work

on:
  push:
    branches: [ main ]
    paths:
      - 'website/**'
      - 'admin/**'
      - '.github/workflows/staging-to-production-deployment-fallback.yml'
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip comprehensive tests (emergency deployment only)'
        required: false
        default: false
        type: boolean
      force_production:
        description: 'Force production deployment without staging tests'
        required: false
        default: false
        type: boolean

env:
  STAGING_BUCKET: 'robert-consulting-staging-website'
  PRODUCTION_BUCKET: 'robert-consulting-website'
  STAGING_URL: 'https://staging.robertconsulting.net'
  PRODUCTION_URL: 'https://robertconsulting.net'

jobs:
  # Stage 1: Deploy to Staging
  deploy-to-staging:
    name: ğŸ§ª Deploy to Staging Environment
    runs-on: ubuntu-latest
    if: github.event.inputs.force_production != 'true'
    outputs:
      staging-deployed: ${{ steps.deploy-staging.outcome == 'success' }}
      staging-url: ${{ env.STAGING_URL }}
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ”§ Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: ğŸ§¹ Clean and prepare website files
        run: |
          echo "ğŸ§¹ Preparing website files for staging deployment..."
          
          # Remove any test/debug files that shouldn't be deployed
          find website/ -name "*.test.*" -delete || true
          find website/ -name "*debug*" -delete || true
          find website/ -name "*temp*" -delete || true
          
          # Ensure proper file permissions
          find website/ -type f -name "*.html" -exec chmod 644 {} \;
          find website/ -type f -name "*.css" -exec chmod 644 {} \;
          find website/ -type f -name "*.js" -exec chmod 644 {} \;
          
          echo "âœ… Website files prepared for staging"

      - name: ğŸš€ Deploy website to staging
        id: deploy-staging
        run: |
          echo "ğŸš€ Deploying website to staging environment..."
          
          # Sync website files to staging bucket
          aws s3 sync website/ s3://${{ env.STAGING_BUCKET }} \
            --delete \
            --exclude "*.tf" \
            --exclude "*.tfvars" \
            --exclude "*.tfstate*" \
            --exclude "terraform/" \
            --exclude "backup/" \
            --exclude "*.test.*" \
            --exclude "*debug*" \
            --exclude "*temp*" \
            --cache-control "public, max-age=3600" \
            --metadata "deployment=staging,commit=${{ github.sha }}"
          
          echo "âœ… Website deployed to staging S3 bucket"
          
          # Create CloudFront invalidation for staging
          STAGING_DISTRIBUTION_ID=$(aws cloudfront list-distributions \
            --query "DistributionList.Items[?Comment=='Robert Consulting Staging Website'].Id" \
            --output text)
          
          if [ -n "$STAGING_DISTRIBUTION_ID" ]; then
            echo "ğŸ”„ Creating CloudFront invalidation for staging..."
            aws cloudfront create-invalidation \
              --distribution-id $STAGING_DISTRIBUTION_ID \
              --paths "/*"
            echo "âœ… Staging CloudFront invalidation created"
          else
            echo "âš ï¸ Could not find staging CloudFront distribution"
          fi

      - name: â³ Wait for staging deployment
        run: |
          echo "â³ Waiting for staging deployment to be ready..."
          sleep 30
          
          # Test staging site accessibility
          for i in {1..10}; do
            if curl -f -s -I "${{ env.STAGING_URL }}" > /dev/null; then
              echo "âœ… Staging site is accessible"
              break
            else
              echo "â³ Waiting for staging site... (attempt $i/10)"
              sleep 10
            fi
          done

      - name: ğŸ“Š Staging deployment summary
        run: |
          echo "## ğŸ§ª Staging Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: âœ… Successfully deployed to staging" >> $GITHUB_STEP_SUMMARY
          echo "- **Staging URL**: ${{ env.STAGING_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: \`${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployed by**: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Timestamp**: $(date -u)" >> $GITHUB_STEP_SUMMARY

  # Stage 2: Comprehensive Testing
  comprehensive-testing:
    name: ğŸ§ª Comprehensive Test Battery
    runs-on: ubuntu-latest
    needs: deploy-to-staging
    if: github.event.inputs.skip_tests != 'true' && github.event.inputs.force_production != 'true'
    outputs:
      tests-passed: ${{ steps.test-summary.outcome == 'success' }}
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ”§ Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: ğŸ§ª Test 1: Basic Functionality Tests
        run: |
          echo "ğŸ§ª Running basic functionality tests..."
          
          # Test main pages
          PAGES=("" "dashboard.html" "learning.html" "monitoring.html" "best-practices.html")
          
          for page in "${PAGES[@]}"; do
            URL="${{ env.STAGING_URL }}/$page"
            echo "Testing: $URL"
            
            # Test HTTP status
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$URL")
            if [ "$STATUS" != "200" ]; then
              echo "âŒ Failed: $URL returned status $STATUS"
              exit 1
            fi
            
            # Test content presence
            if ! curl -s "$URL" | grep -q "<!DOCTYPE html>"; then
              echo "âŒ Failed: $URL missing DOCTYPE"
              exit 1
            fi
            
            echo "âœ… $URL passed basic tests"
          done
          
          echo "âœ… All basic functionality tests passed"

      - name: ğŸ›¡ï¸ Test 2: Security Headers Validation
        run: |
          echo "ğŸ›¡ï¸ Validating security headers..."
          
          # Test security headers on main page
          HEADERS=$(curl -s -I "${{ env.STAGING_URL }}")
          
          REQUIRED_HEADERS=(
            "x-frame-options: DENY"
            "referrer-policy: strict-origin-when-cross-origin"
            "content-security-policy:"
            "strict-transport-security:"
            "x-content-type-options:"
          )
          
          for header in "${REQUIRED_HEADERS[@]}"; do
            if ! echo "$HEADERS" | grep -qi "$header"; then
              echo "âŒ Missing security header: $header"
              exit 1
            fi
            echo "âœ… Found security header: $header"
          done
          
          echo "âœ… All security headers present"

      - name: ğŸ“Š Test Summary
        id: test-summary
        run: |
          echo "## ğŸ§ª Comprehensive Test Results" >> $GITHUB_STEP_SUMMARY
          echo "- **Basic Functionality**: âœ… Passed" >> $GITHUB_STEP_SUMMARY
          echo "- **Security Headers**: âœ… Passed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**All tests passed!** Ready for production deployment." >> $GITHUB_STEP_SUMMARY

  # Stage 3: Manual Approval Gate (Using Action)
  manual-approval:
    name: ğŸ‘¥ Manual Approval for Production
    runs-on: ubuntu-latest
    needs: [deploy-to-staging, comprehensive-testing]
    if: github.event.inputs.force_production != 'true'
    steps:
      - name: ğŸ‘¥ Manual Approval Required
        uses: trstringer/manual-approval@v1
        with:
          secret: ${{ secrets.GITHUB_TOKEN }}
          approvers: Necron-99
          minimum-approvals: 1
          issue-title: "Production Deployment Approval Required"
          issue-body: |
            ## ğŸš€ Production Deployment Approval Required
            
            **Commit**: `${{ github.sha }}`  
            **Branch**: `${{ github.ref_name }}`  
            **Author**: ${{ github.actor }}  
            **Staging URL**: ${{ env.STAGING_URL }}  
            **Production URL**: ${{ env.PRODUCTION_URL }}  
            
            ### âœ… Pre-deployment Checklist:
            - [x] Code deployed to staging successfully
            - [x] Comprehensive tests passed
            - [x] Security headers validated
            
            ### ğŸ“‹ To Approve:
            Comment on this issue with: **APPROVE**
            
            ### ğŸ“‹ To Reject:
            Comment on this issue with: **REJECT**
            
            The deployment will proceed automatically once approved.

  # Stage 4: Production Deployment
  deploy-to-production:
    name: ğŸš€ Deploy to Production
    runs-on: ubuntu-latest
    needs: [deploy-to-staging, comprehensive-testing, manual-approval]
    if: always() && (needs.manual-approval.result == 'success' || github.event.inputs.force_production == 'true')
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ”§ Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: ğŸ§¹ Clean and prepare production files
        run: |
          echo "ğŸ§¹ Preparing website files for production deployment..."
          
          # Remove any test/debug files that shouldn't be deployed
          find website/ -name "*.test.*" -delete || true
          find website/ -name "*debug*" -delete || true
          find website/ -name "*temp*" -delete || true
          
          # Ensure proper file permissions
          find website/ -type f -name "*.html" -exec chmod 644 {} \;
          find website/ -type f -name "*.css" -exec chmod 644 {} \;
          find website/ -type f -name "*.js" -exec chmod 644 {} \;
          
          echo "âœ… Website files prepared for production"

      - name: ğŸš€ Deploy website to production
        run: |
          echo "ğŸš€ Deploying website to production environment..."
          
          # Sync website files to production bucket
          aws s3 sync website/ s3://${{ env.PRODUCTION_BUCKET }} \
            --delete \
            --exclude "*.tf" \
            --exclude "*.tfvars" \
            --exclude "*.tfstate*" \
            --exclude "terraform/" \
            --exclude "backup/" \
            --exclude "*.test.*" \
            --exclude "*debug*" \
            --exclude "*temp*" \
            --cache-control "public, max-age=3600" \
            --metadata "deployment=production,commit=${{ github.sha }}"
          
          echo "âœ… Website deployed to production S3 bucket"
          
          # Create CloudFront invalidation for production
          PRODUCTION_DISTRIBUTION_ID=$(aws cloudfront list-distributions \
            --query "DistributionList.Items[?Comment=='Robert Consulting Website'].Id" \
            --output text)
          
          if [ -n "$PRODUCTION_DISTRIBUTION_ID" ]; then
            echo "ğŸ”„ Creating CloudFront invalidation for production..."
            aws cloudfront create-invalidation \
              --distribution-id $PRODUCTION_DISTRIBUTION_ID \
              --paths "/*"
            echo "âœ… Production CloudFront invalidation created"
          else
            echo "âš ï¸ Could not find production CloudFront distribution"
          fi

      - name: â³ Wait for production deployment
        run: |
          echo "â³ Waiting for production deployment to be ready..."
          sleep 30
          
          # Test production site accessibility
          for i in {1..10}; do
            if curl -f -s -I "${{ env.PRODUCTION_URL }}" > /dev/null; then
              echo "âœ… Production site is accessible"
              break
            else
              echo "â³ Waiting for production site... (attempt $i/10)"
              sleep 10
            fi
          done

      - name: ğŸ” Production validation
        run: |
          echo "ğŸ” Validating production deployment..."
          
          # Test main page
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${{ env.PRODUCTION_URL }}")
          if [ "$STATUS" != "200" ]; then
            echo "âŒ Production site returned status $STATUS"
            exit 1
          fi
          
          # Test security headers
          HEADERS=$(curl -s -I "${{ env.PRODUCTION_URL }}")
          if ! echo "$HEADERS" | grep -qi "x-frame-options"; then
            echo "âŒ Missing security headers on production"
            exit 1
          fi
          
          echo "âœ… Production deployment validated successfully"

      - name: ğŸ“Š Production deployment summary
        run: |
          echo "## ğŸš€ Production Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: âœ… Successfully deployed to production" >> $GITHUB_STEP_SUMMARY
          echo "- **Production URL**: ${{ env.PRODUCTION_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployed by**: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Timestamp**: $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "- **Validation**: âœ… All checks passed" >> $GITHUB_STEP_SUMMARY
