name: 🚀 Comprehensive Staging to Production Pipeline

on:
  push:
    branches: [staging]
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip tests and deploy directly to production'
        required: false
        default: false
        type: boolean

env:
  STAGING_BUCKET: robert-consulting-staging-website
  PRODUCTION_BUCKET: robert-consulting-website
  STAGING_DISTRIBUTION_ID: E23HB5TWK5BF44
  PRODUCTION_DISTRIBUTION_ID: E36DBYPHUUKB3V

jobs:
  # Stage 1: Deploy to Staging
  deploy-to-staging:
    name: 🧪 Deploy to Staging
    runs-on: ubuntu-latest
    outputs:
      staging-url: ${{ steps.deploy.outputs.staging-url }}
      deployment-id: ${{ steps.deploy.outputs.deployment-id }}
    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4

      - name: 🔧 Configure AWS credentials
        run: |
          aws configure set aws_access_key_id ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws configure set aws_secret_access_key ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws configure set default.region us-east-1

      - name: 🚀 Deploy to Staging
        id: deploy
        run: |
          echo "🚀 Deploying to staging environment..."
          
          # Deploy website files to staging S3
          aws s3 sync website/ s3://${{ env.STAGING_BUCKET }}/ \
            --exclude "*.md" \
            --exclude "*.json" \
            --exclude "*.txt" \
            --exclude "*.log" \
            --exclude "terraform/*" \
            --exclude "backup/*" \
            --exclude "scripts/*" \
            --exclude "lambda/*" \
            --exclude "admin/*"
          
          # Create CloudFront invalidation for staging
          INVALIDATION_ID=$(aws cloudfront create-invalidation \
            --distribution-id ${{ env.STAGING_DISTRIBUTION_ID }} \
            --paths "/*" \
            --query 'Invalidation.Id' \
            --output text)
          
          echo "staging-url=https://d3guz3lq4sqlvl.cloudfront.net" >> $GITHUB_OUTPUT
          echo "deployment-id=$INVALIDATION_ID" >> $GITHUB_OUTPUT
          
          echo "✅ Staging deployment completed"
          echo "🔗 Staging URL: https://d3guz3lq4sqlvl.cloudfront.net"
          echo "🔄 Invalidation ID: $INVALIDATION_ID"

      - name: ⏳ Wait for CloudFront propagation
        run: |
          echo "⏳ Waiting for CloudFront cache to propagate..."
          sleep 30

  # Stage 2: Comprehensive Testing
  comprehensive-testing:
    name: 🧪 Comprehensive Testing Suite
    runs-on: ubuntu-latest
    needs: deploy-to-staging
    if: ${{ !inputs.skip_tests }}
    permissions:
      contents: read
      security-events: write
      issues: write
      pull-requests: write
    outputs:
      tests-passed: ${{ steps.test-results.outputs.all-tests-passed }}
      security-score: ${{ steps.security-test.outputs.security-score }}
      performance-score: ${{ steps.performance-test.outputs.performance-score }}
      security-check-passed: ${{ steps.security-blocking-check.outputs.security-check-passed }}
    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4

      - name: 🔧 Configure AWS credentials
        run: |
          aws configure set aws_access_key_id ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws configure set aws_secret_access_key ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws configure set default.region us-east-1

      - name: 🌐 Basic Functionality Tests
        id: basic-tests
        run: |
          echo "🌐 Running basic functionality tests..."
          
          # Test main pages with staging access secret
          STAGING_URL="https://d3guz3lq4sqlvl.cloudfront.net"
          ACCESS_SECRET="staging-access-2025"
          
          echo "🔍 Debug: Testing URLs from GitHub Actions runner..."
          echo "STAGING_URL: $STAGING_URL"
          echo "ACCESS_SECRET: $ACCESS_SECRET"
          echo "Full test URL: $STAGING_URL/?secret=$ACCESS_SECRET"
          
          # Test staging site without access key first
          echo "Testing staging site without access key..."
          NO_KEY_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$STAGING_URL/")
          echo "Staging site without key status: $NO_KEY_STATUS"
          
          # Test staging site with access secret
          echo "Testing staging site with access secret..."
          echo "Testing URL: $STAGING_URL/?secret=$ACCESS_SECRET"
          WITH_SECRET_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$STAGING_URL/?secret=$ACCESS_SECRET")
          echo "Staging site with secret status: $WITH_SECRET_STATUS"
          
          # If we get 403, wait and retry (CloudFront function propagation)
          if [ "$WITH_SECRET_STATUS" = "403" ]; then
            echo "⚠️ Got 403, waiting 30 seconds for CloudFront function propagation..."
            sleep 30
            WITH_SECRET_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$STAGING_URL/?secret=$ACCESS_SECRET")
            echo "Staging site with secret status after retry: $WITH_SECRET_STATUS"
          fi
          
          # Test homepage with detailed debugging and retry
          echo "Testing homepage..."
          HOMEPAGE_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$STAGING_URL/?secret=$ACCESS_SECRET")
          echo "Homepage status code: $HOMEPAGE_STATUS"
          
          # Retry if we get 403 (CloudFront function propagation issue)
          if [ "$HOMEPAGE_STATUS" = "403" ]; then
            echo "⚠️ Homepage got 403, retrying after 15 seconds..."
            sleep 15
            HOMEPAGE_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$STAGING_URL/?secret=$ACCESS_SECRET")
            echo "Homepage status code after retry: $HOMEPAGE_STATUS"
          fi
          
          if [ "$HOMEPAGE_STATUS" = "200" ]; then
            echo "✅ Homepage accessible"
            HOMEPAGE_OK=true
          else
            echo "❌ Homepage not accessible (status: $HOMEPAGE_STATUS)"
            HOMEPAGE_OK=false
          fi
          
          # Test dashboard with detailed debugging
          echo "Testing dashboard..."
          DASHBOARD_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$STAGING_URL/dashboard.html?secret=$ACCESS_SECRET")
          echo "Dashboard status code: $DASHBOARD_STATUS"
          if [ "$DASHBOARD_STATUS" = "200" ]; then
            echo "✅ Dashboard accessible"
            DASHBOARD_OK=true
          else
            echo "❌ Dashboard not accessible (status: $DASHBOARD_STATUS)"
            DASHBOARD_OK=false
          fi
          
          # Test learning page with detailed debugging
          echo "Testing learning page..."
          LEARNING_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$STAGING_URL/learning.html?secret=$ACCESS_SECRET")
          echo "Learning page status code: $LEARNING_STATUS"
          if [ "$LEARNING_STATUS" = "200" ]; then
            echo "✅ Learning page accessible"
            LEARNING_OK=true
          else
            echo "❌ Learning page not accessible (status: $LEARNING_STATUS)"
            LEARNING_OK=false
          fi
          
          # Test CSS and JS loading with detailed debugging
          echo "Testing CSS files..."
          CSS_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$STAGING_URL/css/main.css")
          echo "CSS status code: $CSS_STATUS"
          if [ "$CSS_STATUS" = "200" ]; then
            echo "✅ CSS files loading"
            CSS_OK=true
          else
            echo "❌ CSS files not loading (status: $CSS_STATUS)"
            CSS_OK=false
          fi
          
          echo "Testing JS files..."
          JS_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$STAGING_URL/dashboard-script.js")
          echo "JS status code: $JS_STATUS"
          if [ "$JS_STATUS" = "200" ]; then
            echo "✅ JS files loading"
            JS_OK=true
          else
            echo "❌ JS files not loading (status: $JS_STATUS)"
            JS_OK=false
          fi
          
          # Overall result
          if [ "$HOMEPAGE_OK" = "true" ] && [ "$DASHBOARD_OK" = "true" ] && [ "$LEARNING_OK" = "true" ] && [ "$CSS_OK" = "true" ] && [ "$JS_OK" = "true" ]; then
            echo "basic-tests-passed=true" >> $GITHUB_OUTPUT
            echo "✅ All basic functionality tests passed"
          else
            echo "basic-tests-passed=false" >> $GITHUB_OUTPUT
            echo "❌ Some basic functionality tests failed"
            exit 1
          fi

      - name: 📊 Dashboard Data Validation Tests
        id: dashboard-tests
        run: |
          echo "📊 Running dashboard data validation tests..."
          
          # Install Node.js 22.20 LTS
          curl -fsSL https://deb.nodesource.com/setup_22.x | sudo -E bash -
          sudo apt-get install -y nodejs
          
          # Verify Node.js version
          echo "Node.js version: $(node --version)"
          
          # Run strict dashboard API tests
          echo "🔍 Testing dashboard API endpoint (strict mode)..."
          node scripts/test-dashboard-strict.js
          
          if [ $? -eq 0 ]; then
            echo "✅ Dashboard API tests passed (strict mode)"
            echo "dashboard-api-tests-passed=true" >> $GITHUB_OUTPUT
          else
            echo "❌ Dashboard API tests failed (strict mode) - deployment blocked"
            echo "dashboard-api-tests-passed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Run dashboard UI tests (updated for no service health section)
          echo "🌐 Testing dashboard UI (no service health section)..."
          node scripts/test-dashboard-ui.js
          
          if [ $? -eq 0 ]; then
            echo "✅ Dashboard UI tests passed"
            echo "dashboard-ui-tests-passed=true" >> $GITHUB_OUTPUT
          else
            echo "❌ Dashboard UI tests failed"
            echo "dashboard-ui-tests-passed=false" >> $GITHUB_OUTPUT
          fi
          
          # Test staging dashboard specifically
          echo "🧪 Testing staging dashboard functionality..."
          STAGING_URL="https://d3guz3lq4sqlvl.cloudfront.net"
          ACCESS_SECRET="staging-access-2025"
          
          # Test staging dashboard API
          echo "Testing staging dashboard API..."
          STAGING_API_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://lbfggdldp3.execute-api.us-east-1.amazonaws.com/prod/dashboard-data")
          echo "Staging API status: $STAGING_API_STATUS"
          
          if [ "$STAGING_API_STATUS" = "200" ]; then
            echo "✅ Staging dashboard API accessible"
            echo "staging-api-accessible=true" >> $GITHUB_OUTPUT
          else
            echo "❌ Staging dashboard API not accessible"
            echo "staging-api-accessible=false" >> $GITHUB_OUTPUT
          fi
          
          # Test staging dashboard page
          echo "Testing staging dashboard page..."
          STAGING_DASHBOARD_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$STAGING_URL/dashboard.html?secret=$ACCESS_SECRET")
          echo "Staging dashboard status: $STAGING_DASHBOARD_STATUS"
          
          if [ "$STAGING_DASHBOARD_STATUS" = "200" ]; then
            echo "✅ Staging dashboard page accessible"
            echo "staging-dashboard-accessible=true" >> $GITHUB_OUTPUT
          else
            echo "❌ Staging dashboard page not accessible"
            echo "staging-dashboard-accessible=false" >> $GITHUB_OUTPUT
          fi

      - name: 🔒 Security Headers Test
        id: security-test
        run: |
          echo "🔒 Testing security headers..."
          
          STAGING_URL="https://d3guz3lq4sqlvl.cloudfront.net"
          ACCESS_KEY="staging-access-2025"
          SECURITY_SCORE=0
          MAX_SCORE=8
          
          # Test security headers
          HEADERS=$(curl -s -I "$STAGING_URL/?key=$ACCESS_KEY")
          
          # Check for required security headers
          if echo "$HEADERS" | grep -qi "strict-transport-security"; then
            echo "✅ HSTS header present"
            SECURITY_SCORE=$((SECURITY_SCORE + 1))
          else
            echo "❌ HSTS header missing"
          fi
          
          if echo "$HEADERS" | grep -qi "x-content-type-options"; then
            echo "✅ X-Content-Type-Options header present"
            SECURITY_SCORE=$((SECURITY_SCORE + 1))
          else
            echo "❌ X-Content-Type-Options header missing"
          fi
          
          if echo "$HEADERS" | grep -qi "x-frame-options"; then
            echo "✅ X-Frame-Options header present"
            SECURITY_SCORE=$((SECURITY_SCORE + 1))
          else
            echo "❌ X-Frame-Options header missing"
          fi
          
          if echo "$HEADERS" | grep -qi "x-xss-protection"; then
            echo "✅ X-XSS-Protection header present"
            SECURITY_SCORE=$((SECURITY_SCORE + 1))
          else
            echo "❌ X-XSS-Protection header missing"
          fi
          
          if echo "$HEADERS" | grep -qi "referrer-policy"; then
            echo "✅ Referrer-Policy header present"
            SECURITY_SCORE=$((SECURITY_SCORE + 1))
          else
            echo "❌ Referrer-Policy header missing"
          fi
          
          if echo "$HEADERS" | grep -qi "content-security-policy"; then
            echo "✅ Content-Security-Policy header present"
            SECURITY_SCORE=$((SECURITY_SCORE + 1))
          else
            echo "❌ Content-Security-Policy header missing"
          fi
          
          if echo "$HEADERS" | grep -qi "permissions-policy"; then
            echo "✅ Permissions-Policy header present"
            SECURITY_SCORE=$((SECURITY_SCORE + 1))
          else
            echo "❌ Permissions-Policy header missing"
          fi
          
          if echo "$HEADERS" | grep -qi "cross-origin-embedder-policy"; then
            echo "✅ Cross-Origin-Embedder-Policy header present"
            SECURITY_SCORE=$((SECURITY_SCORE + 1))
          else
            echo "❌ Cross-Origin-Embedder-Policy header missing"
          fi
          
          echo "security-score=$SECURITY_SCORE" >> $GITHUB_OUTPUT
          echo "🔒 Security score: $SECURITY_SCORE/$MAX_SCORE"
          
          # Require at least 6/8 security headers
          if [ $SECURITY_SCORE -ge 6 ]; then
            echo "✅ Security headers test passed"
          else
            echo "❌ Security headers test failed (minimum 6/8 required)"
            exit 1
          fi

      - name: ⚡ Performance Test
        id: performance-test
        run: |
          echo "⚡ Running performance tests..."
          
          STAGING_URL="https://d3guz3lq4sqlvl.cloudfront.net"
          ACCESS_KEY="staging-access-2025"
          
          # Test response time
          RESPONSE_TIME=$(curl -s -o /dev/null -w "%{time_total}" "$STAGING_URL/?key=$ACCESS_KEY")
          RESPONSE_TIME_MS=$(echo "$RESPONSE_TIME * 1000" | bc -l | cut -d. -f1)
          
          echo "⚡ Response time: ${RESPONSE_TIME_MS}ms"
          
          # Performance scoring
          if [ $RESPONSE_TIME_MS -lt 1000 ]; then
            PERFORMANCE_SCORE=100
            echo "✅ Excellent performance (< 1s)"
          elif [ $RESPONSE_TIME_MS -lt 2000 ]; then
            PERFORMANCE_SCORE=80
            echo "✅ Good performance (< 2s)"
          elif [ $RESPONSE_TIME_MS -lt 3000 ]; then
            PERFORMANCE_SCORE=60
            echo "⚠️ Acceptable performance (< 3s)"
          else
            PERFORMANCE_SCORE=40
            echo "❌ Poor performance (> 3s)"
          fi
          
          echo "performance-score=$PERFORMANCE_SCORE" >> $GITHUB_OUTPUT
          echo "⚡ Performance score: $PERFORMANCE_SCORE/100"
          
          # Require at least 60/100 performance score
          if [ $PERFORMANCE_SCORE -ge 60 ]; then
            echo "✅ Performance test passed"
          else
            echo "❌ Performance test failed (minimum 60/100 required)"
            exit 1
          fi

      - name: 🔍 OWASP ZAP Security Scan
        id: zap-scan
        run: |
          echo "🔍 Running OWASP ZAP Security Scan on staging environment..."
          
          # Set target URL with access key (use CloudFront domain for better reliability)
          STAGING_URL="https://d3guz3lq4sqlvl.cloudfront.net"
          ACCESS_KEY="staging-access-2025"
          TARGET_URL="$STAGING_URL/?secret=$ACCESS_KEY"
          echo "🎯 Target URL: $TARGET_URL"
          
          # Test connectivity before running ZAP
          echo "🔍 Testing connectivity to staging environment..."
          if curl -f -s -I "$TARGET_URL" --connect-timeout 10 --max-time 30 > /dev/null; then
            echo "✅ Staging environment is accessible"
          else
            echo "❌ Staging environment is not accessible, trying fallback..."
            # Try the custom domain as fallback
            FALLBACK_URL="https://staging.robertconsulting.net/?secret=$ACCESS_KEY"
            if curl -f -s -I "$FALLBACK_URL" --connect-timeout 10 --max-time 30 > /dev/null; then
              echo "✅ Fallback domain is accessible, using fallback URL"
              TARGET_URL="$FALLBACK_URL"
            else
              echo "❌ Both staging URLs are inaccessible, failing scan"
              exit 1
            fi
          fi
          
          # Create reports directory
          mkdir -p reports
          chmod 777 reports
          
          # Pull the working ZAP image
          echo "📦 Pulling ZAP Docker image..."
          docker pull ghcr.io/zaproxy/zaproxy:stable
          
          # Run ZAP baseline scan
          echo "🔍 Running ZAP baseline scan..."
          if docker run --rm \
            -v $(pwd)/reports:/zap/wrk/:rw \
            -v $(pwd)/reports:/home/zap/:rw \
            --user root \
            -t ghcr.io/zaproxy/zaproxy:stable \
            zap-baseline.py \
            -t "$TARGET_URL" \
            -J staging-baseline-report.json \
            -r staging-baseline-report.html \
            -x staging-baseline-report.xml \
            -a; then
            ZAP_EXIT_CODE=0
            echo "📊 ZAP scan completed successfully with exit code: $ZAP_EXIT_CODE"
          else
            ZAP_EXIT_CODE=$?
            echo "📊 ZAP scan completed with exit code: $ZAP_EXIT_CODE"
          fi
          
          # ZAP exit codes: 0=no issues, 1=low, 2=medium, 3=high risk
          # All of these are SUCCESSFUL scans with findings, not failures
          if [ $ZAP_EXIT_CODE -eq 0 ]; then
            echo "✅ No security issues found"
          elif [ $ZAP_EXIT_CODE -eq 1 ]; then
            echo "⚠️ Low risk security issues found (scan successful)"
          elif [ $ZAP_EXIT_CODE -eq 2 ]; then
            echo "⚠️ Medium risk security issues found (scan successful)"
          elif [ $ZAP_EXIT_CODE -eq 3 ]; then
            echo "⚠️ High risk security issues found (scan successful)"
          else
            echo "❌ ZAP scan failed with unexpected exit code: $ZAP_EXIT_CODE"
            exit 1  # Only fail on unexpected exit codes
          fi
          
          # Check if reports were generated
          echo "📄 Checking for generated reports..."
          if [ -f "reports/staging-baseline-report.json" ]; then
            echo "✅ JSON report generated"
          fi
          if [ -f "reports/staging-baseline-report.html" ]; then
            echo "✅ HTML report generated"
          fi
          if [ -f "reports/staging-baseline-report.xml" ]; then
            echo "✅ XML report generated"
          fi
          
          # Copy reports to root directory for artifact upload
          cp reports/*.json . 2>/dev/null || echo "⚠️ No JSON reports to copy"
          cp reports/*.html . 2>/dev/null || echo "⚠️ No HTML reports to copy"
          cp reports/*.xml . 2>/dev/null || echo "⚠️ No XML reports to copy"
          
          echo "📋 ZAP staging scan summary:"
          echo "Target: $TARGET_URL"
          echo "Exit Code: $ZAP_EXIT_CODE (scan completed successfully)"
          echo "Reports: Available in artifacts"
          
          # Set output for test results
          echo "zap-scan-passed=true" >> $GITHUB_OUTPUT
          echo "zap-exit-code=$ZAP_EXIT_CODE" >> $GITHUB_OUTPUT
          
          # Always exit with 0 for expected ZAP exit codes (0-3)
          # This prevents GitHub Actions from treating security findings as failures
          exit 0

      - name: 🚨 Critical/High Severity Security Check
        id: security-blocking-check
        run: |
          echo "🚨 Checking for critical and high severity security findings..."
          
          # Check if JSON reports exist
          if [ -f "staging-baseline-report.json" ]; then
            echo "📄 Analyzing ZAP JSON reports for blocking security issues..."
            
            # Parse ZAP JSON reports and check for critical/high severity findings
            python3 << 'EOF'
          import json
          import os
          import sys

          def check_blocking_severities():
              """Check for critical and high severity findings that should block deployment"""
              try:
                  # Read ZAP JSON report
                  security_findings = []
                  
                  # Process staging baseline report
                  if os.path.exists('staging-baseline-report.json'):
                      with open('staging-baseline-report.json', 'r') as f:
                          baseline_data = json.load(f)
                      
                      if 'site' in baseline_data and len(baseline_data['site']) > 0:
                          site = baseline_data['site'][0]
                          if 'alerts' in site:
                              false_positive_alerts = [
                                  'Sec-Fetch-User Header is Missing',
                                  'Sec-Fetch-Site Header is Missing', 
                                  'Sec-Fetch-Mode Header is Missing',
                                  'Sec-Fetch-Dest Header is Missing',
                                  'Retrieved from Cache',
                                  'Re-examine Cache-control Directives',
                                  'Storable and Cacheable Content',
                                  'Non-Storable Content',
                                  'Information Disclosure - Suspicious Comments',
                                  'Information Disclosure - Sensitive Information in URL',
                                  'Base64 Disclosure'
                              ]
                              
                              for alert in site['alerts']:
                                  # Skip alerts that are marked as PASS (no security issues)
                                  if alert.get('confidence') == 'PASS':
                                      continue
                                  
                                  # Skip false positive alerts
                                  alert_name = alert.get('name', '')
                                  if alert_name in false_positive_alerts:
                                      continue
                                      
                                  security_findings.append(alert)
                  
                  # Count findings by severity
                  critical_count = 0
                  high_count = 0
                  medium_count = 0
                  low_count = 0
                  informational_count = 0
                  
                  for finding in security_findings:
                      risk_desc = finding.get('riskdesc', 'Unknown')
                      # Extract the main risk level (before parentheses)
                      if '(' in risk_desc:
                          risk_level = risk_desc.split('(')[0].strip()
                      else:
                          risk_level = risk_desc
                      
                      if risk_level == 'Critical':
                          critical_count += 1
                      elif risk_level == 'High':
                          high_count += 1
                      elif risk_level == 'Medium':
                          medium_count += 1
                      elif risk_level == 'Low':
                          low_count += 1
                      elif risk_level == 'Informational':
                          informational_count += 1
                  
                  print(f"📊 Security Findings Summary:")
                  print(f"  🔴 Critical: {critical_count}")
                  print(f"  🟠 High: {high_count}")
                  print(f"  🟡 Medium: {medium_count}")
                  print(f"  🟢 Low: {low_count}")
                  print(f"  🔵 Informational: {informational_count}")
                  
                  # Check for blocking severities
                  blocking_findings = critical_count + high_count
                  
                  if blocking_findings > 0:
                      print(f"")
                      print(f"🚨 DEPLOYMENT BLOCKED: Found {blocking_findings} critical/high severity security findings!")
                      print(f"   Critical: {critical_count}")
                      print(f"   High: {high_count}")
                      print(f"")
                      print(f"❌ Production deployment cannot proceed until these security issues are resolved.")
                      print(f"   Please review the security issues created by this workflow and fix them.")
                      print(f"   Then re-run the workflow to verify the fixes.")
                      return False
                  else:
                      print(f"✅ No critical or high severity security findings found.")
                      print(f"   Deployment can proceed safely.")
                      return True
                      
              except Exception as e:
                  print(f"❌ Error analyzing security findings: {e}")
                  # If we can't analyze, err on the side of caution and block deployment
                  print(f"🚨 DEPLOYMENT BLOCKED: Unable to analyze security findings.")
                  print(f"   Please check the ZAP reports manually before proceeding.")
                  return False

          # Run the check and exit with appropriate code
          if check_blocking_severities():
              sys.exit(0)  # Success - no blocking findings
          else:
              sys.exit(1)  # Failure - blocking findings found
          EOF
            
            # Check the exit code from the Python script
            PYTHON_EXIT_CODE=$?
            if [ $PYTHON_EXIT_CODE -eq 0 ]; then
              echo "✅ Security check passed - no blocking findings"
              echo "security-check-passed=true" >> $GITHUB_OUTPUT
            else
              echo "❌ Security check failed - blocking findings found"
              echo "security-check-passed=false" >> $GITHUB_OUTPUT
              exit 1
            fi
          else
            echo "⚠️ No ZAP JSON reports found - cannot perform security check"
            echo "security-check-passed=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: 📤 Upload ZAP Scan Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: staging-zap-reports
          path: |
            *.html
            *.json
            *.xml
          retention-days: 30
        continue-on-error: true

      - name: 🏷️ Create Required Labels
        if: always()
        run: |
          echo "🏷️ Creating required labels for security issues..."
          
          # Create labels if they don't exist
          labels=("security" "automated-scan" "risk-high" "risk-medium" "risk-low" "risk-informational" "zap-finding" "summary" "staging-scan")
          
          for label in "${labels[@]}"; do
            if ! gh label list | grep -q "^$label$"; then
              echo "Creating label: $label"
              gh label create "$label" --description "Security scan related label" --color "0366d6" 2>/dev/null || echo "Label $label already exists or creation failed"
            else
              echo "Label $label already exists"
            fi
          done
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: 🔍 Create GitHub Issues for Security Findings
        if: always()
        run: |
          echo "🔍 Analyzing ZAP scan results and creating GitHub issues..."
          
          # Check if JSON reports exist
          if [ -f "staging-baseline-report.json" ]; then
            echo "📄 Found ZAP JSON reports, analyzing findings..."
            
            # Parse ZAP JSON reports and create issues for each finding
            python3 << 'EOF'
          import json
          import os
          import subprocess
          import sys
          from datetime import datetime, timezone

          def create_github_issue(title, body, labels):
              """Create a GitHub issue with the given title, body, and labels"""
              try:
                  cmd = ["gh", "issue", "create", "--title", title, "--body", body]
                  if labels:
                      cmd.extend(["--label", labels])
                  
                  result = subprocess.run(cmd, capture_output=True, text=True)
                  if result.returncode == 0:
                      print(f"✅ Created issue: {title}")
                      return True
                  else:
                      print(f"❌ Failed to create issue: {title}")
                      print(f"Error: {result.stderr}")
                      return False
              except Exception as e:
                  print(f"❌ Exception creating issue: {e}")
                  return False

          def update_github_issue(issue_number, body):
              """Update an existing GitHub issue with new information"""
              try:
                  cmd = ["gh", "issue", "comment", str(issue_number), "--body", body]
                  result = subprocess.run(cmd, capture_output=True, text=True)
                  if result.returncode == 0:
                      print(f"✅ Updated issue #{issue_number}")
                      return True
                  else:
                      print(f"❌ Failed to update issue #{issue_number}")
                      return False
              except Exception as e:
                  print(f"❌ Exception updating issue: {e}")
                  return False

          def get_existing_issue(alert_name):
              """Check if an issue already exists for this alert"""
              try:
                  # Search for existing issues with this alert name
                  result = subprocess.run([
                      "gh", "issue", "list", 
                      "--search", f"in:title \"{alert_name}\" label:staging-scan state:open",
                      "--json", "number,title,body"
                  ], capture_output=True, text=True)
                  
                  if result.returncode == 0:
                      issues = json.loads(result.stdout)
                      for issue in issues:
                          if alert_name in issue['title']:
                              return issue['number']
                  return None
              except Exception as e:
                  print(f"❌ Error checking for existing issues: {e}")
                  return None

          def get_risk_color(risk):
              """Get color emoji for risk level"""
              risk_colors = {
                  "High": "🔴",
                  "Medium": "🟡", 
                  "Low": "🟢",
                  "Informational": "🔵"
              }
              return risk_colors.get(risk, "⚪")

          def get_remediation_steps(alert_name):
              """Get remediation steps for common security issues"""
              remediations = {
                  "Missing Anti-clickjacking Header": """
          ### Remediation Steps:
          1. Add X-Frame-Options header to all responses
          2. Set to 'DENY' or 'SAMEORIGIN' based on requirements
          3. Example: `X-Frame-Options: DENY`
          4. Update CloudFront Response Headers Policy if using CDN
          """,
                  "X-Content-Type-Options Header Missing": """
          ### Remediation Steps:
          1. Add X-Content-Type-Options header to all responses
          2. Set to 'nosniff' to prevent MIME type sniffing
          3. Example: `X-Content-Type-Options: nosniff`
          4. Update CloudFront Response Headers Policy if using CDN
          """,
                  "Strict-Transport-Security Defined via META": """
          ### Remediation Steps:
          1. Move HSTS from meta tag to HTTP header
          2. Add Strict-Transport-Security header to all HTTPS responses
          3. Example: `Strict-Transport-Security: max-age=31536000; includeSubDomains; preload`
          4. Update CloudFront Response Headers Policy if using CDN
          """,
                  "Server Leaks Version Information": """
          ### Remediation Steps:
          1. Remove or obfuscate Server header information
          2. Configure web server to not reveal version details
          3. Use generic server identification
          4. Update CloudFront to strip server headers
          """,
                  "Permissions Policy Header Not Set": """
          ### Remediation Steps:
          1. Add Permissions-Policy header to restrict browser features
          2. Example: `Permissions-Policy: camera=(), microphone=(), geolocation=()`
          3. Configure based on your application's needs
          4. Update CloudFront Response Headers Policy if using CDN
          """,
                  "Sub Resource Integrity Attribute Missing": """
          ### Remediation Steps:
          1. Add integrity attributes to external script/link tags
          2. Generate SRI hashes for external resources
          3. Example: `<script src="..." integrity="sha384-..." crossorigin="anonymous"></script>`
          4. Use tools like https://www.srihash.org/ to generate hashes
          """
              }
              return remediations.get(alert_name, """
          ### Remediation Steps:
          1. Review the security finding details in the ZAP report
          2. Consult OWASP guidelines for this vulnerability type
          3. Implement appropriate security controls
          4. Test the fix and re-scan to verify resolution
          """)

          try:
              # Read ZAP JSON report
              all_findings = []
              report_sources = []
              
              # Process staging baseline report
              if os.path.exists('staging-baseline-report.json'):
                  print("📄 Processing staging-baseline-report.json...")
                  with open('staging-baseline-report.json', 'r') as f:
                      baseline_data = json.load(f)
                  
                  if 'site' in baseline_data and len(baseline_data['site']) > 0:
                      site = baseline_data['site'][0]
                      if 'alerts' in site:
                          for alert in site['alerts']:
                              alert['scan_source'] = 'staging-baseline'
                              all_findings.append(alert)
                          report_sources.append('staging-baseline')
                          print(f"📊 Found {len(site['alerts'])} alerts in staging baseline report")
              
              print(f"📊 Found {len(all_findings)} total alerts across {len(report_sources)} reports")
              print(f"📊 Report sources: {', '.join(report_sources)}")
              
              # Filter out PASS alerts and false positives
              security_findings = []
              false_positive_alerts = [
                  'Sec-Fetch-User Header is Missing',
                  'Sec-Fetch-Site Header is Missing', 
                  'Sec-Fetch-Mode Header is Missing',
                  'Sec-Fetch-Dest Header is Missing',
                  'Retrieved from Cache',
                  'Re-examine Cache-control Directives',
                  'Storable and Cacheable Content',
                  'Non-Storable Content',
                  'Information Disclosure - Suspicious Comments',
                  'Information Disclosure - Sensitive Information in URL',
                  'Base64 Disclosure'
              ]
              
              for finding in all_findings:
                  # Skip alerts that are marked as PASS (no security issues)
                  if finding.get('confidence') == 'PASS':
                      continue
                  
                  # Skip false positive alerts
                  alert_name = finding.get('name', '')
                  if alert_name in false_positive_alerts:
                      print(f"🔍 Filtering out false positive: {alert_name}")
                      continue
                      
                  security_findings.append(finding)
              
              print(f"📊 Found {len(security_findings)} security findings to process (excluding PASS alerts)")
              
              # Group findings by alert name to avoid duplicate issues
              grouped_findings = {}
              for finding in security_findings:
                  alert_name = finding.get('name', 'Unknown Alert')
                  if alert_name not in grouped_findings:
                      grouped_findings[alert_name] = []
                  grouped_findings[alert_name].append(finding)
              
              # Create or update issues for each unique finding type
              issues_created = 0
              issues_updated = 0
              for alert_name, alert_findings in grouped_findings.items():
                  # Get risk level (clean up risk description to remove parentheses)
                  risk_levels = [f.get('riskdesc', 'Unknown') for f in alert_findings]
                  # Extract the main risk level (before parentheses)
                  clean_risk_levels = []
                  for risk in risk_levels:
                      if '(' in risk:
                          clean_risk = risk.split('(')[0].strip()
                      else:
                          clean_risk = risk
                      clean_risk_levels.append(clean_risk)
                  
                  risk_level = max(clean_risk_levels, key=lambda x: {'High': 3, 'Medium': 2, 'Low': 1, 'Informational': 0}.get(x, 0))
                  
                  # Count instances and track scan sources
                  instance_count = len(alert_findings)
                  scan_sources = list(set([f.get('scan_source', 'unknown') for f in alert_findings]))
                  scan_sources_str = ', '.join(scan_sources)
                  
                  # Create issue title
                  risk_emoji = get_risk_color(risk_level)
                  issue_title = f"{risk_emoji} Security: {alert_name} ({risk_level} Risk) - Staging"
                  
                  # Create issue body
                  issue_body = f"""## Security Finding: {alert_name}

          **Risk Level:** {risk_level}  
          **Instances Found:** {instance_count}  
          **Scan Sources:** {scan_sources_str}
          **Scan Date:** {datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S')} UTC  
          **Target:** https://d3guz3lq4sqlvl.cloudfront.net/?secret=staging-access-2025
          **Environment:** Staging (Pre-Production)

          ### Description
          {alert_findings[0].get('desc', 'No description available')}

          ### Solution
          {alert_findings[0].get('solution', 'No solution provided')}

          {get_remediation_steps(alert_name)}

          ### Affected URLs
          """
                  
                  # Add affected URLs (limit to first 10 to avoid huge issues)
                  for i, finding in enumerate(alert_findings[:10]):
                      if 'instances' in finding:
                          for instance in finding['instances'][:3]:  # Limit instances per finding
                              url = instance.get('uri', 'Unknown URL')
                              issue_body += f"- {url}\n"
                  
                  if instance_count > 10:
                      issue_body += f"- ... and {instance_count - 10} more instances\n"
                  
                  issue_body += f"""
          ### References
          - [OWASP ZAP Alert Reference](https://www.zaproxy.org/docs/alerts/)
          - [Workflow Run]({os.environ.get('GITHUB_SERVER_URL', '')}/{os.environ.get('GITHUB_REPOSITORY', '')}/actions/runs/{os.environ.get('GITHUB_RUN_ID', '')})

          ### Labels
          - `security`
          - `automated-scan`
          - `staging-scan`
          - `risk-{risk_level.lower()}`
          - `zap-finding`
          """
                  
                  # Create labels
                  labels = f"security,automated-scan,staging-scan,risk-{risk_level.lower()},zap-finding"
                  
                  # Check if issue already exists
                  existing_issue_number = get_existing_issue(alert_name)
                  
                  if existing_issue_number:
                      # Update existing issue with new scan results
                      update_comment = f"""## 🔄 Security Scan Update

          **Update Date:** {datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S')} UTC  
          **Instances Found:** {instance_count}  
          **Risk Level:** {risk_level}

          ### Current Status
          This security issue is still present in the latest staging security scan.

          ### Scan Details
          - **Target:** https://d3guz3lq4sqlvl.cloudfront.net/?secret=staging-access-2025
          - **Environment:** Staging (Pre-Production)
          - **Scan Sources:** {scan_sources_str}

          ### Next Steps
          1. Review the remediation steps above
          2. Implement the necessary fixes
          3. Re-run the security scan to verify resolution

          ### Workflow Information
          - **Workflow Run:** {os.environ.get('GITHUB_SERVER_URL', '')}/{os.environ.get('GITHUB_REPOSITORY', '')}/actions/runs/{os.environ.get('GITHUB_RUN_ID', '')}
          - **Commit:** {os.environ.get('GITHUB_SHA', '')}
          - **Branch:** {os.environ.get('GITHUB_REF_NAME', '')}
          """
                      
                      if update_github_issue(existing_issue_number, update_comment):
                          issues_updated += 1
                  else:
                      # Create new issue
                      if create_github_issue(issue_title, issue_body, labels):
                          issues_created += 1
              
              print(f"✅ Created {issues_created} new security issues")
              print(f"✅ Updated {issues_updated} existing security issues")
              
              # Create summary issue if findings were found
              if issues_created > 0 or issues_updated > 0:
                  summary_title = f"🔒 Staging Security Scan Summary - {datetime.now(timezone.utc).strftime('%Y-%m-%d')}"
                  summary_body = f"""## Staging Security Scan Summary

          **Scan Date:** {datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S')} UTC  
          **Target:** https://d3guz3lq4sqlvl.cloudfront.net/?secret=staging-access-2025
          **Environment:** Staging (Pre-Production)
          **Scan Sources:** {', '.join(report_sources)}
          **Findings:** {len(security_findings)} total instances across {len(grouped_findings)} unique issues  
          **Issues Created:** {issues_created}
          **Issues Updated:** {issues_updated}

          ### Scan Results
          - **High Risk:** {len([f for f in security_findings if 'High' in f.get('riskdesc', '')])} instances
          - **Medium Risk:** {len([f for f in security_findings if 'Medium' in f.get('riskdesc', '')])} instances  
          - **Low Risk:** {len([f for f in security_findings if 'Low' in f.get('riskdesc', '')])} instances
          - **Informational:** {len([f for f in security_findings if 'Informational' in f.get('riskdesc', '')])} instances

          ### Next Steps
          1. Review the individual security issues created/updated above
          2. Prioritize High and Medium risk findings
          3. Implement fixes and re-run scans to verify resolution
          4. Check the workflow artifacts for detailed ZAP reports

          ### Workflow Information
          - **Workflow Run:** {os.environ.get('GITHUB_SERVER_URL', '')}/{os.environ.get('GITHUB_REPOSITORY', '')}/actions/runs/{os.environ.get('GITHUB_RUN_ID', '')}
          - **Commit:** {os.environ.get('GITHUB_SHA', '')}
          - **Branch:** {os.environ.get('GITHUB_REF_NAME', '')}
          """
                  
                  create_github_issue(summary_title, summary_body, "security,automated-scan,staging-scan,summary")
                  print("✅ Created staging security scan summary issue")
              
          except Exception as e:
              print(f"❌ Error processing ZAP results: {e}")
              # Fallback to simple issue creation
              issue_title = f"🔒 OWASP ZAP Staging Security Scan - {datetime.now(timezone.utc).strftime('%Y-%m-%d')}"
              issue_body = f"""## Staging Security Scan Results

          **Scan Date:** {datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S')} UTC  
          **Target:** https://d3guz3lq4sqlvl.cloudfront.net/?secret=staging-access-2025
          **Environment:** Staging (Pre-Production)
          **Scan Type:** Baseline

          ### Scan Status
          ✅ Security scan completed successfully  
          📄 Reports generated and uploaded as artifacts

          ### Artifacts Available
          - HTML Report: Available in workflow artifacts
          - JSON Report: Available in workflow artifacts  
          - XML Report: Available in workflow artifacts

          ### Next Steps
          1. Review the uploaded artifacts for detailed scan results
          2. Address any security findings identified in the scan
          3. Re-run the scan after implementing fixes

          ### Workflow Information
          - **Workflow Run:** {os.environ.get('GITHUB_SERVER_URL', '')}/{os.environ.get('GITHUB_REPOSITORY', '')}/actions/runs/{os.environ.get('GITHUB_RUN_ID', '')}
          - **Commit:** {os.environ.get('GITHUB_SHA', '')}
          - **Branch:** {os.environ.get('GITHUB_REF_NAME', '')}
          """
              create_github_issue(issue_title, issue_body, "security,automated-scan,staging-scan")
          EOF
          else
            echo "⚠️ No ZAP JSON reports found, skipping detailed issue creation"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: 🔄 Close Resolved Security Issues
        if: always()
        run: |
          echo "🔍 Checking for resolved security issues to close..."
          
          # Check if JSON reports exist
          if [ -f "staging-baseline-report.json" ]; then
            echo "📄 Found ZAP JSON reports, checking for resolved issues..."
            
            python3 << 'EOF'
          import json
          import os
          import subprocess
          import sys
          from datetime import datetime, timezone

          def close_github_issue(issue_number, comment):
              """Close a GitHub issue with a comment"""
              try:
                  # Add comment to issue
                  subprocess.run([
                      "gh", "issue", "comment", str(issue_number), 
                      "--body", comment
                  ], check=True)
                  
                  # Close the issue
                  subprocess.run([
                      "gh", "issue", "close", str(issue_number)
                  ], check=True)
                  
                  print(f"✅ Closed issue #{issue_number}")
                  return True
              except Exception as e:
                  print(f"❌ Failed to close issue #{issue_number}: {e}")
                  return False

          def get_current_findings():
              """Get current security findings from ZAP report"""
              security_findings = []
              
              # Process staging baseline report
              if os.path.exists('staging-baseline-report.json'):
                  with open('staging-baseline-report.json', 'r') as f:
                      baseline_data = json.load(f)
                  
                  if 'site' in baseline_data and len(baseline_data['site']) > 0:
                      site = baseline_data['site'][0]
                      if 'alerts' in site:
                          false_positive_alerts = [
                              'Sec-Fetch-User Header is Missing',
                              'Sec-Fetch-Site Header is Missing', 
                              'Sec-Fetch-Mode Header is Missing',
                              'Sec-Fetch-Dest Header is Missing',
                              'Retrieved from Cache',
                              'Re-examine Cache-control Directives',
                              'Storable and Cacheable Content',
                              'Non-Storable Content',
                              'Information Disclosure - Suspicious Comments',
                              'Information Disclosure - Sensitive Information in URL',
                              'Base64 Disclosure'
                          ]
                          
                          for alert in site['alerts']:
                              # Skip alerts that are marked as PASS (no security issues)
                              if alert.get('confidence') == 'PASS':
                                  continue
                              
                              # Skip false positive alerts
                              alert_name = alert.get('name', '')
                              if alert_name in false_positive_alerts:
                                  continue
                                  
                              security_findings.append(alert)
              
              return security_findings

          def get_open_security_issues():
              """Get all open security issues"""
              try:
                  result = subprocess.run([
                      "gh", "issue", "list", 
                      "--label", "security,automated-scan,staging-scan",
                      "--state", "open",
                      "--json", "number,title,labels"
                  ], capture_output=True, text=True)
                  
                  if result.returncode == 0:
                      return json.loads(result.stdout)
                  else:
                      print("⚠️ Could not retrieve open issues")
                      return []
              except Exception as e:
                  print(f"❌ Error retrieving open issues: {e}")
                  return []

          try:
              # Get current security findings
              current_findings = get_current_findings()
              current_alert_names = set(finding.get('name', '') for finding in current_findings)
              
              print(f"📊 Current scan found {len(current_findings)} security findings")
              print(f"📊 Current alert types: {', '.join(current_alert_names)}")
              
              # Get open security issues
              open_issues = get_open_security_issues()
              print(f"📊 Found {len(open_issues)} open security issues")
              
              closed_count = 0
              
              for issue in open_issues:
                  issue_number = issue['number']
                  issue_title = issue['title']
                  
                  # Skip summary issues
                  if 'Summary' in issue_title:
                      continue
                  
                  # Extract alert name from issue title
                  # Format: "🔴 Security: Missing Anti-clickjacking Header (High Risk) - Staging"
                  alert_name = None
                  if 'Security:' in issue_title:
                      # Extract the part between "Security:" and "("
                      parts = issue_title.split('Security:')
                      if len(parts) > 1:
                          alert_part = parts[1].split('(')[0].strip()
                          alert_name = alert_part
                  
                  if alert_name and alert_name not in current_alert_names:
                      # This vulnerability is no longer found in the current scan
                      print(f"🔍 Issue #{issue_number} ({alert_name}) - vulnerability no longer found, closing...")
                      
                      closure_comment = f"""## ✅ Security Issue Resolved

          **Resolution Date:** {datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M:%S')} UTC  
          **Scan Target:** https://d3guz3lq4sqlvl.cloudfront.net/?secret=staging-access-2025
          **Environment:** Staging (Pre-Production)
          **Vulnerability:** {alert_name}

          ### Resolution Details
          This security issue has been automatically closed because the latest OWASP ZAP staging security scan found **no instances** of this specific vulnerability.

          ### Scan Results
          - **Vulnerability Type:** {alert_name}
          - **Current Instances:** 0 (previously found instances have been resolved)
          - **Scan Status:** ✅ Clean

          ### Verification
          - ✅ Latest staging security scan completed successfully
          - ✅ No instances of "{alert_name}" found
          - ✅ Issue automatically resolved

          ### Next Steps
          - Monitor future security scans to ensure this issue doesn't reoccur
          - If you believe this closure is incorrect, please reopen the issue with details

          ### Workflow Information
          - **Workflow Run:** {os.environ.get('GITHUB_SERVER_URL', '')}/{os.environ.get('GITHUB_REPOSITORY', '')}/actions/runs/{os.environ.get('GITHUB_RUN_ID', '')}
          - **Commit:** {os.environ.get('GITHUB_SHA', '')}
          - **Branch:** {os.environ.get('GITHUB_REF_NAME', '')}
          """
                      
                      if close_github_issue(issue_number, closure_comment):
                          closed_count += 1
                  elif alert_name:
                      print(f"📝 Issue #{issue_number} ({alert_name}) - vulnerability still present, keeping open")
                  else:
                      print(f"⚠️ Issue #{issue_number} - could not extract alert name from title: {issue_title}")
              
              if closed_count > 0:
                  print(f"✅ Closed {closed_count} resolved security issues")
              else:
                  print("📝 No resolved security issues found to close")
                  
          except Exception as e:
              print(f"❌ Error processing ZAP results for issue closure: {e}")
          EOF
          else
            echo "⚠️ No ZAP JSON reports found, skipping issue closure check"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: 📊 Test Results Summary
        id: test-results
        run: |
          echo "📊 Test Results Summary:"
          echo "  ✅ Basic Functionality: Passed"
          echo "  ✅ Security Headers: Passed (${{ steps.security-test.outputs.security-score }}/8)"
          echo "  ✅ Performance: Passed (${{ steps.performance-test.outputs.performance-score }}/100)"
          echo "  ✅ OWASP ZAP Scan: Passed (Exit Code: ${{ steps.zap-scan.outputs.zap-exit-code }})"
          echo "  ✅ Security Severity Check: Passed (${{ steps.security-blocking-check.outputs.security-check-passed }})"
          echo ""
          echo "all-tests-passed=true" >> $GITHUB_OUTPUT
          echo "🎉 All tests passed! Ready for production deployment."

  # Stage 3: Production Deployment
  deploy-to-production:
    name: 🚀 Deploy to Production
    runs-on: ubuntu-latest
    needs: [deploy-to-staging, comprehensive-testing]
    if: ${{ always() && (needs.comprehensive-testing.outputs.tests-passed == 'true' || inputs.skip_tests == true) && (needs.comprehensive-testing.result == 'success' || inputs.skip_tests == true) }}
    environment: production-deployment
    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4

      - name: 🔧 Configure AWS credentials
        run: |
          aws configure set aws_access_key_id ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws configure set aws_secret_access_key ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws configure set default.region us-east-1

      - name: 🚀 Deploy to Production
        run: |
          echo "🚀 Deploying to production environment..."
          
          # Deploy website files to production S3
          aws s3 sync website/ s3://${{ env.PRODUCTION_BUCKET }}/ \
            --exclude "*.md" \
            --exclude "*.json" \
            --exclude "*.txt" \
            --exclude "*.log" \
            --exclude "terraform/*" \
            --exclude "backup/*" \
            --exclude "scripts/*" \
            --exclude "lambda/*" \
            --exclude "admin/*"
          
          # Create CloudFront invalidation for production
          INVALIDATION_ID=$(aws cloudfront create-invalidation \
            --distribution-id ${{ env.PRODUCTION_DISTRIBUTION_ID }} \
            --paths "/*" \
            --query 'Invalidation.Id' \
            --output text)
          
          echo "✅ Production deployment completed"
          echo "🔗 Production URL: https://robertconsulting.net"
          echo "🔄 Invalidation ID: $INVALIDATION_ID"

      - name: 📊 Refresh Dashboard Statistics
        run: |
          echo "📊 Refreshing dashboard statistics..."
          
          # Invoke the stats refresher Lambda function
          LAMBDA_RESPONSE=$(aws lambda invoke \
            --function-name dashboard-stats-refresher \
            --payload '{}' \
            --cli-binary-format raw-in-base64-out \
            /tmp/lambda-response.json)
          
          if [ $? -eq 0 ]; then
            echo "✅ Dashboard statistics refreshed successfully"
            cat /tmp/lambda-response.json
          else
            echo "❌ Failed to refresh dashboard statistics"
            echo "Continuing deployment (non-critical failure)"
          fi

      - name: 📊 Deployment Summary
        env:
          SKIP_TESTS: ${{ inputs.skip_tests }}
          SECURITY_SCORE: ${{ needs.comprehensive-testing.outputs.security-score }}
          PERFORMANCE_SCORE: ${{ needs.comprehensive-testing.outputs.performance-score }}
        run: |
          echo "## 🚀 Production Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ✅ Deployment Details:" >> $GITHUB_STEP_SUMMARY
          echo "- **Staging URL**: https://d3guz3lq4sqlvl.cloudfront.net" >> $GITHUB_STEP_SUMMARY
          echo "- **Production URL**: https://robertconsulting.net" >> $GITHUB_STEP_SUMMARY
          echo "- **Tests Skipped**: $SKIP_TESTS" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "$SKIP_TESTS" != "true" ]; then
            echo "### 🧪 Test Results:" >> $GITHUB_STEP_SUMMARY
            echo "- **Security Score**: $SECURITY_SCORE/8" >> $GITHUB_STEP_SUMMARY
            echo "- **Performance Score**: $PERFORMANCE_SCORE/100" >> $GITHUB_STEP_SUMMARY
            echo "- **All Tests**: ✅ Passed" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 🎉 Status: Successfully deployed to production!" >> $GITHUB_STEP_SUMMARY

  # Stage 4: Post-Deployment Validation
  post-deployment-validation:
    name: ✅ Post-Deployment Validation
    runs-on: ubuntu-latest
    needs: deploy-to-production
    if: ${{ success() }}
    steps:
      - name: 🔧 Configure AWS credentials
        run: |
          aws configure set aws_access_key_id ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws configure set aws_secret_access_key ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws configure set default.region us-east-1

      - name: ✅ Validate Production Deployment
        run: |
          echo "✅ Validating production deployment..."
          
          PRODUCTION_URL="https://robertconsulting.net"
          
          # Test main pages
          if curl -s -o /dev/null -w "%{http_code}" "$PRODUCTION_URL/" | grep -q "200"; then
            echo "✅ Production homepage accessible"
          else
            echo "❌ Production homepage not accessible"
            exit 1
          fi
          
          if curl -s -o /dev/null -w "%{http_code}" "$PRODUCTION_URL/dashboard.html" | grep -q "200"; then
            echo "✅ Production dashboard accessible"
          else
            echo "❌ Production dashboard not accessible"
            exit 1
          fi
          
          echo "🎉 Production deployment validation successful!"
