name: OWASP ZAP Security Scan

on:
  push:
    branches: [ main ]
    paths:
      - 'website/**'
      - 'admin/**'
      - '.github/workflows/owasp-zap-security-scan.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'website/**'
      - 'admin/**'
  schedule:
    # Run security scan daily at 2 AM UTC
    - cron: '0 2 * * *'
  workflow_dispatch:
    inputs:
      target_url:
        description: 'Target URL to scan (default: https://robertconsulting.net)'
        required: false
        default: 'https://robertconsulting.net'

env:
  STAGING_URL: 'http://robert-consulting-testing-site.s3-website-us-east-1.amazonaws.com'
  TARGET_URL: ${{ github.event.inputs.target_url || 'https://robertconsulting.net' }}

jobs:
  zap-baseline-scan:
    name: OWASP ZAP Baseline Scan
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
      issues: write
      pull-requests: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Deploy website to staging for scanning
        run: |
          echo "üß™ Deploying to staging site for ZAP scanning..."
          aws s3 sync website/ s3://robert-consulting-testing-site --delete
          echo "‚úÖ Staging deployment completed"

      - name: Wait for deployment
        run: |
          echo "‚è≥ Waiting for staging deployment to be ready..."
          sleep 30
          echo "‚úÖ Staging site should be ready for scanning"

      - name: Run OWASP ZAP Baseline Scan
        run: |
          echo "üîç Running OWASP ZAP Baseline Scan..."
          
          # Create reports directory
          mkdir -p reports
          chmod 777 reports
          
          # Set target URL
          TARGET_URL="${{ env.STAGING_URL }}"
          echo "üéØ Target URL: $TARGET_URL"
          
          # Pull the working ZAP image
          echo "üì¶ Pulling ZAP Docker image..."
          docker pull ghcr.io/zaproxy/zaproxy:stable
          
          # Run ZAP baseline scan
          echo "üîç Running ZAP baseline scan..."
          if docker run --rm \
            -v $(pwd)/reports:/zap/wrk/:rw \
            -v $(pwd)/reports:/home/zap/:rw \
            --user root \
            -t ghcr.io/zaproxy/zaproxy:stable \
            zap-baseline.py \
            -t "$TARGET_URL" \
            -J baseline-report.json \
            -r baseline-report.html \
            -x baseline-report.xml \
            -a; then
            ZAP_EXIT_CODE=0
            echo "üìä ZAP scan completed successfully with exit code: $ZAP_EXIT_CODE"
          else
            ZAP_EXIT_CODE=$?
            echo "üìä ZAP scan completed with exit code: $ZAP_EXIT_CODE"
          fi
          
          # ZAP exit codes: 0=no issues, 1=low, 2=medium, 3=high risk
          # All of these are SUCCESSFUL scans with findings, not failures
          if [ $ZAP_EXIT_CODE -eq 0 ]; then
            echo "‚úÖ No security issues found"
          elif [ $ZAP_EXIT_CODE -eq 1 ]; then
            echo "‚ö†Ô∏è Low risk security issues found (scan successful)"
          elif [ $ZAP_EXIT_CODE -eq 2 ]; then
            echo "‚ö†Ô∏è Medium risk security issues found (scan successful)"
          elif [ $ZAP_EXIT_CODE -eq 3 ]; then
            echo "‚ö†Ô∏è High risk security issues found (scan successful)"
          else
            echo "‚ùå ZAP scan failed with unexpected exit code: $ZAP_EXIT_CODE"
            exit 1  # Only fail on unexpected exit codes
          fi
          
          # Check if reports were generated
          echo "üìÑ Checking for generated reports..."
          if [ -f "reports/baseline-report.json" ]; then
            echo "‚úÖ JSON report generated"
          fi
          if [ -f "reports/baseline-report.html" ]; then
            echo "‚úÖ HTML report generated"
          fi
          if [ -f "reports/baseline-report.xml" ]; then
            echo "‚úÖ XML report generated"
          fi
          
          # List all files in reports directory
          echo "üìÅ Files in reports directory:"
          ls -la reports/ || echo "‚ùå Reports directory not accessible"
          
          # Copy reports to root directory for artifact upload
          cp reports/*.json . 2>/dev/null || echo "‚ö†Ô∏è No JSON reports to copy"
          cp reports/*.html . 2>/dev/null || echo "‚ö†Ô∏è No HTML reports to copy"
          cp reports/*.xml . 2>/dev/null || echo "‚ö†Ô∏è No XML reports to copy"
          
          echo "üìã ZAP baseline scan summary:"
          echo "Target: $TARGET_URL"
          echo "Exit Code: $ZAP_EXIT_CODE (scan completed successfully)"
          echo "Reports: Available in artifacts"
          
          # Always exit with 0 for expected ZAP exit codes (0-3)
          # This prevents GitHub Actions from treating security findings as failures
          exit 0

      - name: Upload ZAP scan results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: zap-baseline-reports
          path: |
            *.html
            *.json
            *.xml
            *.sarif
          retention-days: 30
        continue-on-error: true

      - name: Upload ZAP results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: always() && hashFiles('*.sarif') != ''
        with:
          sarif_file: '*.sarif'
        continue-on-error: true

      - name: Create GitHub Issues for Security Findings
        if: always()
        run: |
          echo "üîç Analyzing ZAP scan results and creating GitHub issues..."
          
          # Check if JSON report exists
          if [ -f "baseline-report.json" ]; then
            echo "üìÑ Found ZAP JSON report, analyzing findings..."
            
            # Parse ZAP JSON report and create issues for each finding
            python3 << 'EOF'
          import json
          import os
          import subprocess
          import sys
          from datetime import datetime

          def create_github_issue(title, body, labels):
              """Create a GitHub issue with the given title, body, and labels"""
              try:
                  cmd = ["gh", "issue", "create", "--title", title, "--body", body]
                  if labels:
                      cmd.extend(["--label", labels])
                  
                  result = subprocess.run(cmd, capture_output=True, text=True)
                  if result.returncode == 0:
                      print(f"‚úÖ Created issue: {title}")
                      return True
                  else:
                      print(f"‚ùå Failed to create issue: {title}")
                      print(f"Error: {result.stderr}")
                      return False
              except Exception as e:
                  print(f"‚ùå Exception creating issue: {e}")
                  return False

          def get_risk_color(risk):
              """Get color emoji for risk level"""
              risk_colors = {
                  "High": "üî¥",
                  "Medium": "üü°", 
                  "Low": "üü¢",
                  "Informational": "üîµ"
              }
              return risk_colors.get(risk, "‚ö™")

          def get_remediation_steps(alert_name):
              """Get remediation steps for common security issues"""
              remediations = {
                  "Missing Anti-clickjacking Header": """
          ### Remediation Steps:
          1. Add X-Frame-Options header to all responses
          2. Set to 'DENY' or 'SAMEORIGIN' based on requirements
          3. Example: `X-Frame-Options: DENY`
          4. Update CloudFront Response Headers Policy if using CDN
          """,
                  "X-Content-Type-Options Header Missing": """
          ### Remediation Steps:
          1. Add X-Content-Type-Options header to all responses
          2. Set to 'nosniff' to prevent MIME type sniffing
          3. Example: `X-Content-Type-Options: nosniff`
          4. Update CloudFront Response Headers Policy if using CDN
          """,
                  "Strict-Transport-Security Defined via META": """
          ### Remediation Steps:
          1. Move HSTS from meta tag to HTTP header
          2. Add Strict-Transport-Security header to all HTTPS responses
          3. Example: `Strict-Transport-Security: max-age=31536000; includeSubDomains; preload`
          4. Update CloudFront Response Headers Policy if using CDN
          """,
                  "Server Leaks Version Information": """
          ### Remediation Steps:
          1. Remove or obfuscate Server header information
          2. Configure web server to not reveal version details
          3. Use generic server identification
          4. Update CloudFront to strip server headers
          """,
                  "Permissions Policy Header Not Set": """
          ### Remediation Steps:
          1. Add Permissions-Policy header to restrict browser features
          2. Example: `Permissions-Policy: camera=(), microphone=(), geolocation=()`
          3. Configure based on your application's needs
          4. Update CloudFront Response Headers Policy if using CDN
          """,
                  "Sub Resource Integrity Attribute Missing": """
          ### Remediation Steps:
          1. Add integrity attributes to external script/link tags
          2. Generate SRI hashes for external resources
          3. Example: `<script src="..." integrity="sha384-..." crossorigin="anonymous"></script>`
          4. Use tools like https://www.srihash.org/ to generate hashes
          """
              }
              return remediations.get(alert_name, """
          ### Remediation Steps:
          1. Review the security finding details in the ZAP report
          2. Consult OWASP guidelines for this vulnerability type
          3. Implement appropriate security controls
          4. Test the fix and re-scan to verify resolution
          """)

          try:
              # Read ZAP JSON report
              with open('baseline-report.json', 'r') as f:
                  zap_data = json.load(f)
              
              # Extract findings
              findings = []
              if 'site' in zap_data and len(zap_data['site']) > 0:
                  site = zap_data['site'][0]
                  if 'alerts' in site:
                      for alert in site['alerts']:
                          if alert.get('riskcode') in [1, 2, 3]:  # High, Medium, Low risk
                              findings.append(alert)
              
              print(f"üìä Found {len(findings)} security findings to process")
              
              # Group findings by alert name to avoid duplicate issues
              grouped_findings = {}
              for finding in findings:
                  alert_name = finding.get('name', 'Unknown Alert')
                  if alert_name not in grouped_findings:
                      grouped_findings[alert_name] = []
                  grouped_findings[alert_name].append(finding)
              
              # Create issues for each unique finding type
              issues_created = 0
              for alert_name, alert_findings in grouped_findings.items():
                  # Get risk level
                  risk_levels = [f.get('riskdesc', 'Unknown') for f in alert_findings]
                  risk_level = max(risk_levels, key=lambda x: {'High': 3, 'Medium': 2, 'Low': 1, 'Informational': 0}.get(x, 0))
                  
                  # Count instances
                  instance_count = len(alert_findings)
                  
                  # Create issue title
                  risk_emoji = get_risk_color(risk_level)
                  issue_title = f"{risk_emoji} Security: {alert_name} ({risk_level} Risk)"
                  
                  # Create issue body
                  issue_body = f"""## Security Finding: {alert_name}

          **Risk Level:** {risk_level}  
          **Instances Found:** {instance_count}  
          **Scan Date:** {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')} UTC  
          **Target:** ${{ env.STAGING_URL }}

          ### Description
          {alert_findings[0].get('desc', 'No description available')}

          ### Solution
          {alert_findings[0].get('solution', 'No solution provided')}

          {get_remediation_steps(alert_name)}

          ### Affected URLs
          """
                  
                  # Add affected URLs (limit to first 10 to avoid huge issues)
                  for i, finding in enumerate(alert_findings[:10]):
                      if 'instances' in finding:
                          for instance in finding['instances'][:3]:  # Limit instances per finding
                              url = instance.get('uri', 'Unknown URL')
                              issue_body += f"- {url}\n"
                  
                  if instance_count > 10:
                      issue_body += f"- ... and {instance_count - 10} more instances\n"
                  
                  issue_body += f"""
          ### References
          - [OWASP ZAP Alert Reference](https://www.zaproxy.org/docs/alerts/)
          - [Workflow Run]({os.environ.get('GITHUB_SERVER_URL', '')}/{os.environ.get('GITHUB_REPOSITORY', '')}/actions/runs/{os.environ.get('GITHUB_RUN_ID', '')})

          ### Labels
          - `security`
          - `automated-scan`
          - `risk-{risk_level.lower()}`
          - `zap-finding`
          """
                  
                  # Create labels
                  labels = f"security,automated-scan,risk-{risk_level.lower()},zap-finding"
                  
                  # Check if issue already exists
                  try:
                      existing_issues = subprocess.run(
                          ["gh", "issue", "list", "--search", f"in:title {alert_name}", "--json", "number,title"],
                          capture_output=True, text=True
                      )
                      if existing_issues.returncode == 0:
                          existing_data = json.loads(existing_issues.stdout)
                          if existing_data:
                              print(f"üìù Issue already exists for: {alert_name}")
                              continue
                  except:
                      pass
                  
                  # Create the issue
                  if create_github_issue(issue_title, issue_body, labels):
                      issues_created += 1
              
              print(f"‚úÖ Created {issues_created} security issues")
              
              # Create summary issue if findings were found
              if issues_created > 0:
                  summary_title = f"üîí Security Scan Summary - {datetime.utcnow().strftime('%Y-%m-%d')}"
                  summary_body = f"""## Security Scan Summary

          **Scan Date:** {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')} UTC  
          **Target:** ${{ env.STAGING_URL }}  
          **Findings:** {len(findings)} total instances across {len(grouped_findings)} unique issues  
          **Issues Created:** {issues_created}

          ### Scan Results
          - **High Risk:** {len([f for f in findings if f.get('riskdesc') == 'High'])} instances
          - **Medium Risk:** {len([f for f in findings if f.get('riskdesc') == 'Medium'])} instances  
          - **Low Risk:** {len([f for f in findings if f.get('riskdesc') == 'Low'])} instances

          ### Next Steps
          1. Review the individual security issues created above
          2. Prioritize High and Medium risk findings
          3. Implement fixes and re-run scans to verify resolution
          4. Check the workflow artifacts for detailed ZAP reports

          ### Workflow Information
          - **Workflow Run:** {os.environ.get('GITHUB_SERVER_URL', '')}/{os.environ.get('GITHUB_REPOSITORY', '')}/actions/runs/{os.environ.get('GITHUB_RUN_ID', '')}
          - **Commit:** {os.environ.get('GITHUB_SHA', '')}
          - **Branch:** {os.environ.get('GITHUB_REF_NAME', '')}
          """
                  
                  create_github_issue(summary_title, summary_body, "security,automated-scan,summary")
                  print("‚úÖ Created security scan summary issue")
              
          except Exception as e:
              print(f"‚ùå Error processing ZAP results: {e}")
              # Fallback to simple issue creation
              issue_title = f"üîí OWASP ZAP Security Scan - {datetime.utcnow().strftime('%Y-%m-%d')}"
              issue_body = f"""## Security Scan Results

          **Scan Date:** {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')} UTC  
          **Target:** ${{ env.STAGING_URL }}  
          **Scan Type:** Baseline

          ### Scan Status
          ‚úÖ Security scan completed successfully  
          üìÑ Reports generated and uploaded as artifacts

          ### Artifacts Available
          - HTML Report: Available in workflow artifacts
          - JSON Report: Available in workflow artifacts  
          - SARIF Report: Available in workflow artifacts (if generated)

          ### Next Steps
          1. Review the uploaded artifacts for detailed scan results
          2. Check the GitHub Security tab for SARIF results (if code scanning is enabled)
          3. Address any security findings identified in the scan

          ### Workflow Information
          - **Workflow Run:** {os.environ.get('GITHUB_SERVER_URL', '')}/{os.environ.get('GITHUB_REPOSITORY', '')}/actions/runs/{os.environ.get('GITHUB_RUN_ID', '')}
          - **Commit:** {os.environ.get('GITHUB_SHA', '')}
          - **Branch:** {os.environ.get('GITHUB_REF_NAME', '')}
          """
              create_github_issue(issue_title, issue_body, "security,automated-scan")
          EOF
          else
            echo "‚ö†Ô∏è No ZAP JSON report found, skipping detailed issue creation"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Close Resolved Security Issues
        if: always()
        run: |
          echo "üîç Checking for resolved security issues to close..."
          
          # Check if JSON report exists and has no findings
          if [ -f "baseline-report.json" ]; then
            echo "üìÑ Found ZAP JSON report, checking for resolved issues..."
            
            python3 << 'EOF'
          import json
          import os
          import subprocess
          import sys
          from datetime import datetime

          def close_github_issue(issue_number, comment):
              """Close a GitHub issue with a comment"""
              try:
                  # Add comment to issue
                  subprocess.run([
                      "gh", "issue", "comment", str(issue_number), 
                      "--body", comment
                  ], check=True)
                  
                  # Close the issue
                  subprocess.run([
                      "gh", "issue", "close", str(issue_number)
                  ], check=True)
                  
                  print(f"‚úÖ Closed issue #{issue_number}")
                  return True
              except Exception as e:
                  print(f"‚ùå Failed to close issue #{issue_number}: {e}")
                  return False

          try:
              # Read ZAP JSON report
              with open('baseline-report.json', 'r') as f:
                  zap_data = json.load(f)
              
              # Check if there are any findings
              findings = []
              if 'site' in zap_data and len(zap_data['site']) > 0:
                  site = zap_data['site'][0]
                  if 'alerts' in site:
                      findings = [alert for alert in site['alerts'] if alert.get('riskcode') in [1, 2, 3]]
              
              # If no findings, check for open security issues to close
              if len(findings) == 0:
                  print("‚úÖ No security findings found - checking for resolved issues to close")
                  
                  # Get all open issues with security labels
                  try:
                      result = subprocess.run([
                          "gh", "issue", "list", 
                          "--label", "security,automated-scan",
                          "--state", "open",
                          "--json", "number,title,labels"
                      ], capture_output=True, text=True)
                      
                      if result.returncode == 0:
                          issues = json.loads(result.stdout)
                          closed_count = 0
                          
                          for issue in issues:
                              issue_number = issue['number']
                              issue_title = issue['title']
                              
                              # Skip summary issues
                              if 'Summary' in issue_title:
                                  continue
                              
                              # Create closure comment
                              closure_comment = f"""## ‚úÖ Security Issue Resolved

          **Resolution Date:** {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')} UTC  
          **Scan Target:** ${{ env.STAGING_URL }}

          ### Resolution Details
          This security issue has been automatically closed because the latest OWASP ZAP security scan found **no security findings** for this vulnerability type.

          ### Scan Results
          - **Total Findings:** 0
          - **High Risk:** 0
          - **Medium Risk:** 0  
          - **Low Risk:** 0

          ### Verification
          - ‚úÖ Latest security scan completed successfully
          - ‚úÖ No instances of this vulnerability found
          - ‚úÖ Issue automatically resolved

          ### Next Steps
          - Monitor future security scans to ensure this issue doesn't reoccur
          - If you believe this closure is incorrect, please reopen the issue with details

          ### Workflow Information
          - **Workflow Run:** {os.environ.get('GITHUB_SERVER_URL', '')}/{os.environ.get('GITHUB_REPOSITORY', '')}/actions/runs/{os.environ.get('GITHUB_RUN_ID', '')}
          - **Commit:** {os.environ.get('GITHUB_SHA', '')}
          - **Branch:** {os.environ.get('GITHUB_REF_NAME', '')}
          """
                              
                              if close_github_issue(issue_number, closure_comment):
                                  closed_count += 1
                          
                          if closed_count > 0:
                              print(f"‚úÖ Closed {closed_count} resolved security issues")
                          else:
                              print("üìù No open security issues found to close")
                      else:
                          print("‚ö†Ô∏è Could not retrieve open issues")
                          
                  except Exception as e:
                      print(f"‚ùå Error checking for issues to close: {e}")
              else:
                  print(f"üìä Found {len(findings)} security findings - no issues to close")
                  
          except Exception as e:
              print(f"‚ùå Error processing ZAP results for issue closure: {e}")
          EOF
          else
            echo "‚ö†Ô∏è No ZAP JSON report found, skipping issue closure check"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate Security Summary
        if: always()
        run: |
          echo "## üîí OWASP ZAP Security Scan Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Target Scanned:** ${{ env.STAGING_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "**Scan Type:** Baseline" >> $GITHUB_STEP_SUMMARY
          echo "**Timestamp:** $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Reports Available:" >> $GITHUB_STEP_SUMMARY
          echo "- HTML Report: Available in workflow artifacts" >> $GITHUB_STEP_SUMMARY
          echo "- JSON Report: Available in workflow artifacts" >> $GITHUB_STEP_SUMMARY
          echo "- SARIF Report: Uploaded to GitHub Security tab (if code scanning enabled)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### GitHub Code Scanning Setup:" >> $GITHUB_STEP_SUMMARY
          echo "To enable SARIF uploads to GitHub Security tab:" >> $GITHUB_STEP_SUMMARY
          echo "1. Go to Settings ‚Üí Security ‚Üí Code scanning" >> $GITHUB_STEP_SUMMARY
          echo "2. Click Set up code scanning" >> $GITHUB_STEP_SUMMARY
          echo "3. Choose Advanced ‚Üí Upload SARIF file" >> $GITHUB_STEP_SUMMARY
          echo "4. This will enable the Security tab integration" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "*Job summary generated at run-time*" >> $GITHUB_STEP_SUMMARY

      - name: Cleanup staging deployment
        if: always()
        run: |
          echo "üßπ Cleaning up staging deployment..."
          # Optional: Remove staging files if needed
          echo "‚úÖ Cleanup completed"

  zap-api-scan:
    name: OWASP ZAP API Scan
    runs-on: ubuntu-latest
    permissions:
      contents: read
      security-events: write
      issues: write
      pull-requests: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Run OWASP ZAP API Scan
        run: |
          echo "üîç Running OWASP ZAP API Scan..."
          
          # Create reports directory
          mkdir -p reports
          chmod 777 reports
          
          # Set target URL
          TARGET_URL="${{ env.TARGET_URL }}"
          echo "üéØ Target URL: $TARGET_URL"
          
          # Pull the working ZAP image
          echo "üì¶ Pulling ZAP Docker image..."
          docker pull ghcr.io/zaproxy/zaproxy:stable
          
          # Run ZAP baseline scan for API endpoints (since we don't have OpenAPI spec)
          echo "üîç Running ZAP baseline scan for API endpoints..."
          if docker run --rm \
            -v $(pwd)/reports:/zap/wrk/:rw \
            -v $(pwd)/reports:/home/zap/:rw \
            --user root \
            -t ghcr.io/zaproxy/zaproxy:stable \
            zap-baseline.py \
            -t "$TARGET_URL" \
            -J api-report.json \
            -r api-report.html \
            -x api-report.xml \
            -a; then
            ZAP_EXIT_CODE=0
            echo "üìä ZAP API scan completed successfully with exit code: $ZAP_EXIT_CODE"
          else
            ZAP_EXIT_CODE=$?
            echo "üìä ZAP API scan completed with exit code: $ZAP_EXIT_CODE"
          fi
          
          # ZAP exit codes: 0=no issues, 1=low, 2=medium, 3=high risk
          # All of these are SUCCESSFUL scans with findings, not failures
          if [ $ZAP_EXIT_CODE -eq 0 ]; then
            echo "‚úÖ No security issues found"
          elif [ $ZAP_EXIT_CODE -eq 1 ]; then
            echo "‚ö†Ô∏è Low risk security issues found (scan successful)"
          elif [ $ZAP_EXIT_CODE -eq 2 ]; then
            echo "‚ö†Ô∏è Medium risk security issues found (scan successful)"
          elif [ $ZAP_EXIT_CODE -eq 3 ]; then
            echo "‚ö†Ô∏è High risk security issues found (scan successful)"
          else
            echo "‚ùå ZAP API scan failed with unexpected exit code: $ZAP_EXIT_CODE"
            exit 1  # Only fail on unexpected exit codes
          fi
          
          # Check if reports were generated
          echo "üìÑ Checking for generated API reports..."
          if [ -f "reports/api-report.json" ]; then
            echo "‚úÖ JSON report generated"
          fi
          if [ -f "reports/api-report.html" ]; then
            echo "‚úÖ HTML report generated"
          fi
          if [ -f "reports/api-report.xml" ]; then
            echo "‚úÖ XML report generated"
          fi
          
          # List all files in reports directory
          echo "üìÅ Files in reports directory:"
          ls -la reports/ || echo "‚ùå Reports directory not accessible"
          
          # Copy reports to root directory for artifact upload
          cp reports/*.json . 2>/dev/null || echo "‚ö†Ô∏è No JSON reports to copy"
          cp reports/*.html . 2>/dev/null || echo "‚ö†Ô∏è No HTML reports to copy"
          cp reports/*.xml . 2>/dev/null || echo "‚ö†Ô∏è No XML reports to copy"
          
          echo "üìã ZAP API scan summary:"
          echo "Target: $TARGET_URL"
          echo "Exit Code: $ZAP_EXIT_CODE (scan completed successfully)"
          echo "Reports: Available in artifacts"
          
          # Always exit with 0 for expected ZAP exit codes (0-3)
          # This prevents GitHub Actions from treating security findings as failures
          exit 0

      - name: Upload API scan results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: zap-api-reports
          path: |
            *.html
            *.json
            *.xml
            *.sarif
          retention-days: 30
        continue-on-error: true

      - name: Upload API scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: always() && hashFiles('*.sarif') != ''
        with:
          sarif_file: '*.sarif'
        continue-on-error: true

      - name: Generate API Scan Summary
        if: always()
        run: |
          echo "## üîç OWASP ZAP API Scan Results" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Target Scanned:** ${{ env.TARGET_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "**Scan Type:** API" >> $GITHUB_STEP_SUMMARY
          echo "**Timestamp:** $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Reports Available:" >> $GITHUB_STEP_SUMMARY
          echo "- HTML Report: Available in workflow artifacts" >> $GITHUB_STEP_SUMMARY
          echo "- JSON Report: Available in workflow artifacts" >> $GITHUB_STEP_SUMMARY
          echo "- SARIF Report: Uploaded to GitHub Security tab (if code scanning enabled)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "*API scan completed successfully*" >> $GITHUB_STEP_SUMMARY