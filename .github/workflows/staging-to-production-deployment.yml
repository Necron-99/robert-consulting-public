name: Staging to Production Deployment Pipeline

on:
  push:
    branches: [ main ]
    paths:
      - 'website/**'
      - 'admin/**'
      - '.github/workflows/staging-to-production-deployment.yml'
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip comprehensive tests (emergency deployment only)'
        required: false
        default: false
        type: boolean
      force_production:
        description: 'Force production deployment without staging tests'
        required: false
        default: false
        type: boolean

env:
  STAGING_BUCKET: 'robert-consulting-staging-website'
  PRODUCTION_BUCKET: 'robert-consulting-website'
  STAGING_URL: 'https://staging.robertconsulting.net'
  PRODUCTION_URL: 'https://robertconsulting.net'
  ADMIN_STAGING_URL: 'https://admin-staging.robertconsulting.net'
  ADMIN_PRODUCTION_URL: 'https://admin.robertconsulting.net'

jobs:
  # Stage 1: Deploy to Staging
  deploy-to-staging:
    name: 🧪 Deploy to Staging Environment
    runs-on: ubuntu-latest
    if: github.event.inputs.force_production != 'true'
    outputs:
      staging-deployed: ${{ steps.deploy-staging.outcome == 'success' }}
      staging-url: ${{ env.STAGING_URL }}
    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4

      - name: 🔧 Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: 🧹 Clean and prepare website files
        run: |
          echo "🧹 Preparing website files for staging deployment..."
          
          # Remove any test/debug files that shouldn't be deployed
          find website/ -name "*.test.*" -delete || true
          find website/ -name "*debug*" -delete || true
          find website/ -name "*temp*" -delete || true
          
          # Ensure proper file permissions
          find website/ -type f -name "*.html" -exec chmod 644 {} \;
          find website/ -type f -name "*.css" -exec chmod 644 {} \;
          find website/ -type f -name "*.js" -exec chmod 644 {} \;
          
          echo "✅ Website files prepared for staging"

      - name: 🚀 Deploy website to staging
        id: deploy-staging
        run: |
          echo "🚀 Deploying website to staging environment..."
          
          # Sync website files to staging bucket
          aws s3 sync website/ s3://${{ env.STAGING_BUCKET }} \
            --delete \
            --exclude "*.tf" \
            --exclude "*.tfvars" \
            --exclude "*.tfstate*" \
            --exclude "terraform/" \
            --exclude "backup/" \
            --exclude "*.test.*" \
            --exclude "*debug*" \
            --exclude "*temp*" \
            --cache-control "public, max-age=3600" \
            --metadata "deployment=staging,commit=${{ github.sha }}"
          
          echo "✅ Website deployed to staging S3 bucket"
          
          # Create CloudFront invalidation for staging
          STAGING_DISTRIBUTION_ID=$(aws cloudfront list-distributions \
            --query "DistributionList.Items[?Comment=='Robert Consulting Staging Website'].Id" \
            --output text)
          
          if [ -n "$STAGING_DISTRIBUTION_ID" ]; then
            echo "🔄 Creating CloudFront invalidation for staging..."
            aws cloudfront create-invalidation \
              --distribution-id $STAGING_DISTRIBUTION_ID \
              --paths "/*"
            echo "✅ Staging CloudFront invalidation created"
          else
            echo "⚠️ Could not find staging CloudFront distribution"
          fi

      - name: ⏳ Wait for staging deployment
        run: |
          echo "⏳ Waiting for staging deployment to be ready..."
          sleep 30
          
          # Test staging site accessibility
          for i in {1..10}; do
            if curl -f -s -I "${{ env.STAGING_URL }}" > /dev/null; then
              echo "✅ Staging site is accessible"
              break
            else
              echo "⏳ Waiting for staging site... (attempt $i/10)"
              sleep 10
            fi
          done

      - name: 📊 Staging deployment summary
        run: |
          echo "## 🧪 Staging Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ✅ Successfully deployed to staging" >> $GITHUB_STEP_SUMMARY
          echo "- **Staging URL**: ${{ env.STAGING_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: \`${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployed by**: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Timestamp**: $(date -u)" >> $GITHUB_STEP_SUMMARY

  # Stage 2: Comprehensive Testing
  comprehensive-testing:
    name: 🧪 Comprehensive Test Battery
    runs-on: ubuntu-latest
    needs: deploy-to-staging
    if: github.event.inputs.skip_tests != 'true' && github.event.inputs.force_production != 'true'
    outputs:
      tests-passed: ${{ steps.test-summary.outcome == 'success' }}
    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4

      - name: 🔧 Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: 🧪 Test 1: Basic Functionality Tests
        run: |
          echo "🧪 Running basic functionality tests..."
          
          # Test main pages
          PAGES=("" "dashboard.html" "learning.html" "monitoring.html" "best-practices.html")
          
          for page in "${PAGES[@]}"; do
            URL="${{ env.STAGING_URL }}/$page"
            echo "Testing: $URL"
            
            # Test HTTP status
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$URL")
            if [ "$STATUS" != "200" ]; then
              echo "❌ Failed: $URL returned status $STATUS"
              exit 1
            fi
            
            # Test content presence
            if ! curl -s "$URL" | grep -q "<!DOCTYPE html>"; then
              echo "❌ Failed: $URL missing DOCTYPE"
              exit 1
            fi
            
            echo "✅ $URL passed basic tests"
          done
          
          echo "✅ All basic functionality tests passed"

      - name: 🛡️ Test 2: Security Headers Validation
        run: |
          echo "🛡️ Validating security headers..."
          
          # Test security headers on main page
          HEADERS=$(curl -s -I "${{ env.STAGING_URL }}")
          
          REQUIRED_HEADERS=(
            "x-frame-options: DENY"
            "referrer-policy: strict-origin-when-cross-origin"
            "content-security-policy:"
            "strict-transport-security:"
            "x-content-type-options:"
          )
          
          for header in "${REQUIRED_HEADERS[@]}"; do
            if ! echo "$HEADERS" | grep -qi "$header"; then
              echo "❌ Missing security header: $header"
              exit 1
            fi
            echo "✅ Found security header: $header"
          done
          
          echo "✅ All security headers present"

      - name: 🔍 Test 3: Content Integrity Tests
        run: |
          echo "🔍 Running content integrity tests..."
          
          # Test for broken links (basic check)
          if curl -s "${{ env.STAGING_URL }}" | grep -q "href=\"#\""; then
            echo "⚠️ Warning: Found empty href attributes"
          fi
          
          # Test for missing images
          if curl -s "${{ env.STAGING_URL }}" | grep -q "src=\"\""; then
            echo "❌ Found empty src attributes"
            exit 1
          fi
          
          # Test for proper meta tags
          if ! curl -s "${{ env.STAGING_URL }}" | grep -q "viewport"; then
            echo "❌ Missing viewport meta tag"
            exit 1
          fi
          
          echo "✅ Content integrity tests passed"

      - name: 📱 Test 4: Responsive Design Tests
        run: |
          echo "📱 Testing responsive design..."
          
          # Test with different user agents
          USER_AGENTS=(
            "Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X)"
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36"
          )
          
          for ua in "${USER_AGENTS[@]}"; do
            if ! curl -s -H "User-Agent: $ua" "${{ env.STAGING_URL }}" | grep -q "viewport"; then
              echo "❌ Responsive design test failed for: $ua"
              exit 1
            fi
            echo "✅ Responsive test passed for: $ua"
          done
          
          echo "✅ All responsive design tests passed"

      - name: ⚡ Test 5: Performance Tests
        run: |
          echo "⚡ Running performance tests..."
          
          # Test page load time
          LOAD_TIME=$(curl -s -o /dev/null -w "%{time_total}" "${{ env.STAGING_URL }}")
          echo "Page load time: ${LOAD_TIME}s"
          
          # Fail if load time is too high (10 seconds)
          if (( $(echo "$LOAD_TIME > 10" | bc -l) )); then
            echo "❌ Page load time too high: ${LOAD_TIME}s"
            exit 1
          fi
          
          # Test for large files
          LARGE_FILES=$(curl -s -I "${{ env.STAGING_URL }}" | grep -i "content-length" | awk '{print $2}' | tr -d '\r')
          if [ -n "$LARGE_FILES" ] && [ "$LARGE_FILES" -gt 5000000 ]; then
            echo "⚠️ Warning: Large page size: ${LARGE_FILES} bytes"
          fi
          
          echo "✅ Performance tests passed"

      - name: 🔒 Test 6: Security Scan (Basic)
        run: |
          echo "🔒 Running basic security scan..."
          
          # Test for common security issues
          CONTENT=$(curl -s "${{ env.STAGING_URL }}")
          
          # Check for hardcoded secrets (basic check)
          if echo "$CONTENT" | grep -qi "password.*="; then
            echo "❌ Potential hardcoded password found"
            exit 1
          fi
          
          # Check for mixed content
          if echo "$CONTENT" | grep -q "http://"; then
            echo "⚠️ Warning: Found HTTP links (should use HTTPS)"
          fi
          
          # Check for proper CSP
          if ! curl -s -I "${{ env.STAGING_URL }}" | grep -qi "content-security-policy"; then
            echo "❌ Missing Content Security Policy"
            exit 1
          fi
          
          echo "✅ Basic security scan passed"

      - name: 📊 Test Summary
        id: test-summary
        run: |
          echo "## 🧪 Comprehensive Test Results" >> $GITHUB_STEP_SUMMARY
          echo "- **Basic Functionality**: ✅ Passed" >> $GITHUB_STEP_SUMMARY
          echo "- **Security Headers**: ✅ Passed" >> $GITHUB_STEP_SUMMARY
          echo "- **Content Integrity**: ✅ Passed" >> $GITHUB_STEP_SUMMARY
          echo "- **Responsive Design**: ✅ Passed" >> $GITHUB_STEP_SUMMARY
          echo "- **Performance**: ✅ Passed" >> $GITHUB_STEP_SUMMARY
          echo "- **Security Scan**: ✅ Passed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**All tests passed!** Ready for production deployment." >> $GITHUB_STEP_SUMMARY

  # Stage 3: Manual Approval Gate
  manual-approval:
    name: 👥 Manual Approval for Production
    runs-on: ubuntu-latest
    needs: [deploy-to-staging, comprehensive-testing]
    if: github.event.inputs.force_production != 'true'
    environment: production-deployment
    steps:
      - name: 📋 Production Deployment Checklist
        run: |
          echo "## 👥 Production Deployment Approval Required" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ✅ Pre-deployment Checklist:" >> $GITHUB_STEP_SUMMARY
          echo "- [x] Code deployed to staging successfully" >> $GITHUB_STEP_SUMMARY
          echo "- [x] Comprehensive tests passed" >> $GITHUB_STEP_SUMMARY
          echo "- [x] Security headers validated" >> $GITHUB_STEP_SUMMARY
          echo "- [x] Performance tests passed" >> $GITHUB_STEP_SUMMARY
          echo "- [x] Responsive design verified" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 📊 Deployment Details:" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: \`${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Author**: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Staging URL**: ${{ env.STAGING_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Production URL**: ${{ env.PRODUCTION_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 🚀 Ready for Production Deployment" >> $GITHUB_STEP_SUMMARY
          echo "Please review the staging environment and approve the production deployment." >> $GITHUB_STEP_SUMMARY

  # Stage 4: Production Deployment
  deploy-to-production:
    name: 🚀 Deploy to Production
    runs-on: ubuntu-latest
    needs: [deploy-to-staging, comprehensive-testing, manual-approval]
    if: always() && (needs.manual-approval.result == 'success' || github.event.inputs.force_production == 'true')
    steps:
      - name: 📥 Checkout code
        uses: actions/checkout@v4

      - name: 🔧 Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: 🧹 Clean and prepare production files
        run: |
          echo "🧹 Preparing website files for production deployment..."
          
          # Remove any test/debug files that shouldn't be deployed
          find website/ -name "*.test.*" -delete || true
          find website/ -name "*debug*" -delete || true
          find website/ -name "*temp*" -delete || true
          
          # Ensure proper file permissions
          find website/ -type f -name "*.html" -exec chmod 644 {} \;
          find website/ -type f -name "*.css" -exec chmod 644 {} \;
          find website/ -type f -name "*.js" -exec chmod 644 {} \;
          
          echo "✅ Website files prepared for production"

      - name: 🚀 Deploy website to production
        run: |
          echo "🚀 Deploying website to production environment..."
          
          # Sync website files to production bucket
          aws s3 sync website/ s3://${{ env.PRODUCTION_BUCKET }} \
            --delete \
            --exclude "*.tf" \
            --exclude "*.tfvars" \
            --exclude "*.tfstate*" \
            --exclude "terraform/" \
            --exclude "backup/" \
            --exclude "*.test.*" \
            --exclude "*debug*" \
            --exclude "*temp*" \
            --cache-control "public, max-age=3600" \
            --metadata "deployment=production,commit=${{ github.sha }}"
          
          echo "✅ Website deployed to production S3 bucket"
          
          # Create CloudFront invalidation for production
          PRODUCTION_DISTRIBUTION_ID=$(aws cloudfront list-distributions \
            --query "DistributionList.Items[?Comment=='Robert Consulting Website'].Id" \
            --output text)
          
          if [ -n "$PRODUCTION_DISTRIBUTION_ID" ]; then
            echo "🔄 Creating CloudFront invalidation for production..."
            aws cloudfront create-invalidation \
              --distribution-id $PRODUCTION_DISTRIBUTION_ID \
              --paths "/*"
            echo "✅ Production CloudFront invalidation created"
          else
            echo "⚠️ Could not find production CloudFront distribution"
          fi

      - name: ⏳ Wait for production deployment
        run: |
          echo "⏳ Waiting for production deployment to be ready..."
          sleep 30
          
          # Test production site accessibility
          for i in {1..10}; do
            if curl -f -s -I "${{ env.PRODUCTION_URL }}" > /dev/null; then
              echo "✅ Production site is accessible"
              break
            else
              echo "⏳ Waiting for production site... (attempt $i/10)"
              sleep 10
            fi
          done

      - name: 🔍 Production validation
        run: |
          echo "🔍 Validating production deployment..."
          
          # Test main page
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${{ env.PRODUCTION_URL }}")
          if [ "$STATUS" != "200" ]; then
            echo "❌ Production site returned status $STATUS"
            exit 1
          fi
          
          # Test security headers
          HEADERS=$(curl -s -I "${{ env.PRODUCTION_URL }}")
          if ! echo "$HEADERS" | grep -qi "x-frame-options"; then
            echo "❌ Missing security headers on production"
            exit 1
          fi
          
          echo "✅ Production deployment validated successfully"

      - name: 📊 Production deployment summary
        run: |
          echo "## 🚀 Production Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ✅ Successfully deployed to production" >> $GITHUB_STEP_SUMMARY
          echo "- **Production URL**: ${{ env.PRODUCTION_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployed by**: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Timestamp**: $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "- **Validation**: ✅ All checks passed" >> $GITHUB_STEP_SUMMARY

  # Stage 5: Post-deployment monitoring
  post-deployment-monitoring:
    name: 📊 Post-deployment Monitoring
    runs-on: ubuntu-latest
    needs: deploy-to-production
    if: always() && needs.deploy-to-production.result == 'success'
    steps:
      - name: 🔧 Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: 📊 Monitor deployment health
        run: |
          echo "📊 Monitoring deployment health..."
          
          # Check CloudWatch metrics
          echo "🔍 Checking CloudFront metrics..."
          
          # Test production site performance
          LOAD_TIME=$(curl -s -o /dev/null -w "%{time_total}" "${{ env.PRODUCTION_URL }}")
          echo "Production load time: ${LOAD_TIME}s"
          
          # Test multiple pages
          PAGES=("" "dashboard.html" "learning.html")
          for page in "${PAGES[@]}"; do
            URL="${{ env.PRODUCTION_URL }}/$page"
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$URL")
            echo "Page $page: HTTP $STATUS"
          done
          
          echo "✅ Post-deployment monitoring complete"

      - name: 📋 Final deployment report
        run: |
          echo "## 📋 Final Deployment Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ✅ Deployment Status: SUCCESS" >> $GITHUB_STEP_SUMMARY
          echo "- **Staging**: ✅ Deployed and tested" >> $GITHUB_STEP_SUMMARY
          echo "- **Testing**: ✅ All tests passed" >> $GITHUB_STEP_SUMMARY
          echo "- **Approval**: ✅ Manually approved" >> $GITHUB_STEP_SUMMARY
          echo "- **Production**: ✅ Deployed and validated" >> $GITHUB_STEP_SUMMARY
          echo "- **Monitoring**: ✅ Health checks passed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 🔗 URLs:" >> $GITHUB_STEP_SUMMARY
          echo "- **Production**: ${{ env.PRODUCTION_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Staging**: ${{ env.STAGING_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### 📊 Next Steps:" >> $GITHUB_STEP_SUMMARY
          echo "1. Monitor production metrics" >> $GITHUB_STEP_SUMMARY
          echo "2. Check CloudWatch dashboards" >> $GITHUB_STEP_SUMMARY
          echo "3. Verify user experience" >> $GITHUB_STEP_SUMMARY
