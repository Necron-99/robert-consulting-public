name: Staging to Production Deployment Pipeline

on:
  push:
    branches: [ main ]
    paths:
      - 'website/**'
      - 'admin/**'
      - '.github/workflows/staging-to-production-deployment.yml'
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip comprehensive tests (emergency deployment only)'
        required: false
        default: false
        type: boolean
      force_production:
        description: 'Force production deployment without staging tests'
        required: false
        default: false
        type: boolean

env:
  STAGING_BUCKET: 'robert-consulting-staging-website'
  PRODUCTION_BUCKET: 'robert-consulting-website'
  STAGING_URL: 'https://staging.robertconsulting.net'
  PRODUCTION_URL: 'https://robertconsulting.net'
  ADMIN_STAGING_URL: 'https://admin-staging.robertconsulting.net'
  ADMIN_PRODUCTION_URL: 'https://admin.robertconsulting.net'

jobs:
  # Stage 1: Deploy to Staging
  deploy-to-staging:
    name: ğŸ§ª Deploy to Staging Environment
    runs-on: ubuntu-latest
    if: github.event.inputs.force_production != 'true'
    outputs:
      staging-deployed: ${{ steps.deploy-staging.outcome == 'success' }}
      staging-url: ${{ env.STAGING_URL }}
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ”§ Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: ğŸ§¹ Clean and prepare website files
        run: |
          echo "ğŸ§¹ Preparing website files for staging deployment..."
          
          # Remove any test/debug files that shouldn't be deployed
          find website/ -name "*.test.*" -delete || true
          find website/ -name "*debug*" -delete || true
          find website/ -name "*temp*" -delete || true
          
          # Ensure proper file permissions
          find website/ -type f -name "*.html" -exec chmod 644 {} \;
          find website/ -type f -name "*.css" -exec chmod 644 {} \;
          find website/ -type f -name "*.js" -exec chmod 644 {} \;
          
          echo "âœ… Website files prepared for staging"

      - name: ğŸš€ Deploy website to staging
        id: deploy-staging
        run: |
          echo "ğŸš€ Deploying website to staging environment..."
          
          # Sync website files to staging bucket
          aws s3 sync website/ s3://${{ env.STAGING_BUCKET }} \
            --delete \
            --exclude "*.tf" \
            --exclude "*.tfvars" \
            --exclude "*.tfstate*" \
            --exclude "terraform/" \
            --exclude "backup/" \
            --exclude "*.test.*" \
            --exclude "*debug*" \
            --exclude "*temp*" \
            --cache-control "public, max-age=3600" \
            --metadata "deployment=staging,commit=${{ github.sha }}"
          
          echo "âœ… Website deployed to staging S3 bucket"
          
          # Create CloudFront invalidation for staging
          STAGING_DISTRIBUTION_ID=$(aws cloudfront list-distributions \
            --query "DistributionList.Items[?Comment=='Robert Consulting Staging Website'].Id" \
            --output text)
          
          if [ -n "$STAGING_DISTRIBUTION_ID" ]; then
            echo "ğŸ”„ Creating CloudFront invalidation for staging..."
            aws cloudfront create-invalidation \
              --distribution-id $STAGING_DISTRIBUTION_ID \
              --paths "/*"
            echo "âœ… Staging CloudFront invalidation created"
          else
            echo "âš ï¸ Could not find staging CloudFront distribution"
          fi

      - name: â³ Wait for staging deployment
        run: |
          echo "â³ Waiting for staging deployment to be ready..."
          sleep 30
          
          # Test staging site accessibility
          for i in {1..10}; do
            if curl -f -s -I "${{ env.STAGING_URL }}" > /dev/null; then
              echo "âœ… Staging site is accessible"
              break
            else
              echo "â³ Waiting for staging site... (attempt $i/10)"
              sleep 10
            fi
          done

      - name: ğŸ“Š Staging deployment summary
        run: |
          echo "## ğŸ§ª Staging Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: âœ… Successfully deployed to staging" >> $GITHUB_STEP_SUMMARY
          echo "- **Staging URL**: ${{ env.STAGING_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: \`${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployed by**: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Timestamp**: $(date -u)" >> $GITHUB_STEP_SUMMARY

  # Stage 2: Comprehensive Testing
  comprehensive-testing:
    name: ğŸ§ª Comprehensive Test Battery
    runs-on: ubuntu-latest
    needs: deploy-to-staging
    if: github.event.inputs.skip_tests != 'true' && github.event.inputs.force_production != 'true'
    outputs:
      tests-passed: ${{ steps.test-summary.outcome == 'success' }}
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ”§ Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: ğŸ§ª Test 1: Basic Functionality Tests
        run: |
          echo "ğŸ§ª Running basic functionality tests..."
          
          # Test main pages
          PAGES=("" "dashboard.html" "learning.html" "monitoring.html" "best-practices.html")
          
          for page in "${PAGES[@]}"; do
            URL="${{ env.STAGING_URL }}/$page"
            echo "Testing: $URL"
            
            # Test HTTP status
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$URL")
            if [ "$STATUS" != "200" ]; then
              echo "âŒ Failed: $URL returned status $STATUS"
              exit 1
            fi
            
            # Test content presence
            if ! curl -s "$URL" | grep -q "<!DOCTYPE html>"; then
              echo "âŒ Failed: $URL missing DOCTYPE"
              exit 1
            fi
            
            echo "âœ… $URL passed basic tests"
          done
          
          echo "âœ… All basic functionality tests passed"

      - name: ğŸ›¡ï¸ Test 2: Security Headers Validation
        run: |
          echo "ğŸ›¡ï¸ Validating security headers..."
          
          # Test security headers on main page
          HEADERS=$(curl -s -I "${{ env.STAGING_URL }}")
          
          REQUIRED_HEADERS=(
            "x-frame-options: DENY"
            "referrer-policy: strict-origin-when-cross-origin"
            "content-security-policy:"
            "strict-transport-security:"
            "x-content-type-options:"
          )
          
          for header in "${REQUIRED_HEADERS[@]}"; do
            if ! echo "$HEADERS" | grep -qi "$header"; then
              echo "âŒ Missing security header: $header"
              exit 1
            fi
            echo "âœ… Found security header: $header"
          done
          
          echo "âœ… All security headers present"

      - name: ğŸ” Test 3: Content Integrity Tests
        run: |
          echo "ğŸ” Running content integrity tests..."
          
          # Test for broken links (basic check)
          if curl -s "${{ env.STAGING_URL }}" | grep -q "href=\"#\""; then
            echo "âš ï¸ Warning: Found empty href attributes"
          fi
          
          # Test for missing images
          if curl -s "${{ env.STAGING_URL }}" | grep -q "src=\"\""; then
            echo "âŒ Found empty src attributes"
            exit 1
          fi
          
          # Test for proper meta tags
          if ! curl -s "${{ env.STAGING_URL }}" | grep -q "viewport"; then
            echo "âŒ Missing viewport meta tag"
            exit 1
          fi
          
          echo "âœ… Content integrity tests passed"

      - name: ğŸ“± Test 4: Responsive Design Tests
        run: |
          echo "ğŸ“± Testing responsive design..."
          
          # Test with different user agents
          USER_AGENTS=(
            "Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X)"
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36"
          )
          
          for ua in "${USER_AGENTS[@]}"; do
            if ! curl -s -H "User-Agent: $ua" "${{ env.STAGING_URL }}" | grep -q "viewport"; then
              echo "âŒ Responsive design test failed for: $ua"
              exit 1
            fi
            echo "âœ… Responsive test passed for: $ua"
          done
          
          echo "âœ… All responsive design tests passed"

      - name: âš¡ Test 5: Performance Tests
        run: |
          echo "âš¡ Running performance tests..."
          
          # Test page load time
          LOAD_TIME=$(curl -s -o /dev/null -w "%{time_total}" "${{ env.STAGING_URL }}")
          echo "Page load time: ${LOAD_TIME}s"
          
          # Fail if load time is too high (10 seconds)
          if (( $(echo "$LOAD_TIME > 10" | bc -l) )); then
            echo "âŒ Page load time too high: ${LOAD_TIME}s"
            exit 1
          fi
          
          # Test for large files
          LARGE_FILES=$(curl -s -I "${{ env.STAGING_URL }}" | grep -i "content-length" | awk '{print $2}' | tr -d '\r')
          if [ -n "$LARGE_FILES" ] && [ "$LARGE_FILES" -gt 5000000 ]; then
            echo "âš ï¸ Warning: Large page size: ${LARGE_FILES} bytes"
          fi
          
          echo "âœ… Performance tests passed"

      - name: ğŸ”’ Test 6: Security Scan (Basic)
        run: |
          echo "ğŸ”’ Running basic security scan..."
          
          # Test for common security issues
          CONTENT=$(curl -s "${{ env.STAGING_URL }}")
          
          # Check for hardcoded secrets (basic check)
          if echo "$CONTENT" | grep -qi "password.*="; then
            echo "âŒ Potential hardcoded password found"
            exit 1
          fi
          
          # Check for mixed content
          if echo "$CONTENT" | grep -q "http://"; then
            echo "âš ï¸ Warning: Found HTTP links (should use HTTPS)"
          fi
          
          # Check for proper CSP
          if ! curl -s -I "${{ env.STAGING_URL }}" | grep -qi "content-security-policy"; then
            echo "âŒ Missing Content Security Policy"
            exit 1
          fi
          
          echo "âœ… Basic security scan passed"

      - name: ğŸ“Š Test Summary
        id: test-summary
        run: |
          echo "## ğŸ§ª Comprehensive Test Results" >> $GITHUB_STEP_SUMMARY
          echo "- **Basic Functionality**: âœ… Passed" >> $GITHUB_STEP_SUMMARY
          echo "- **Security Headers**: âœ… Passed" >> $GITHUB_STEP_SUMMARY
          echo "- **Content Integrity**: âœ… Passed" >> $GITHUB_STEP_SUMMARY
          echo "- **Responsive Design**: âœ… Passed" >> $GITHUB_STEP_SUMMARY
          echo "- **Performance**: âœ… Passed" >> $GITHUB_STEP_SUMMARY
          echo "- **Security Scan**: âœ… Passed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**All tests passed!** Ready for production deployment." >> $GITHUB_STEP_SUMMARY

  # Stage 3: Manual Approval Gate
  manual-approval:
    name: ğŸ‘¥ Manual Approval for Production
    runs-on: ubuntu-latest
    needs: [deploy-to-staging, comprehensive-testing]
    if: github.event.inputs.force_production != 'true'
    environment: production-deployment
    steps:
      - name: ğŸ“‹ Production Deployment Checklist
        run: |
          echo "## ğŸ‘¥ Production Deployment Approval Required" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### âœ… Pre-deployment Checklist:" >> $GITHUB_STEP_SUMMARY
          echo "- [x] Code deployed to staging successfully" >> $GITHUB_STEP_SUMMARY
          echo "- [x] Comprehensive tests passed" >> $GITHUB_STEP_SUMMARY
          echo "- [x] Security headers validated" >> $GITHUB_STEP_SUMMARY
          echo "- [x] Performance tests passed" >> $GITHUB_STEP_SUMMARY
          echo "- [x] Responsive design verified" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ“Š Deployment Details:" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: \`${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Author**: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Staging URL**: ${{ env.STAGING_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Production URL**: ${{ env.PRODUCTION_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸš€ Ready for Production Deployment" >> $GITHUB_STEP_SUMMARY
          echo "Please review the staging environment and approve the production deployment." >> $GITHUB_STEP_SUMMARY

  # Stage 4: Production Deployment
  deploy-to-production:
    name: ğŸš€ Deploy to Production
    runs-on: ubuntu-latest
    needs: [deploy-to-staging, comprehensive-testing, manual-approval]
    if: always() && (needs.manual-approval.result == 'success' || github.event.inputs.force_production == 'true')
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ”§ Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: ğŸ§¹ Clean and prepare production files
        run: |
          echo "ğŸ§¹ Preparing website files for production deployment..."
          
          # Remove any test/debug files that shouldn't be deployed
          find website/ -name "*.test.*" -delete || true
          find website/ -name "*debug*" -delete || true
          find website/ -name "*temp*" -delete || true
          
          # Ensure proper file permissions
          find website/ -type f -name "*.html" -exec chmod 644 {} \;
          find website/ -type f -name "*.css" -exec chmod 644 {} \;
          find website/ -type f -name "*.js" -exec chmod 644 {} \;
          
          echo "âœ… Website files prepared for production"

      - name: ğŸš€ Deploy website to production
        run: |
          echo "ğŸš€ Deploying website to production environment..."
          
          # Sync website files to production bucket
          aws s3 sync website/ s3://${{ env.PRODUCTION_BUCKET }} \
            --delete \
            --exclude "*.tf" \
            --exclude "*.tfvars" \
            --exclude "*.tfstate*" \
            --exclude "terraform/" \
            --exclude "backup/" \
            --exclude "*.test.*" \
            --exclude "*debug*" \
            --exclude "*temp*" \
            --cache-control "public, max-age=3600" \
            --metadata "deployment=production,commit=${{ github.sha }}"
          
          echo "âœ… Website deployed to production S3 bucket"
          
          # Create CloudFront invalidation for production
          PRODUCTION_DISTRIBUTION_ID=$(aws cloudfront list-distributions \
            --query "DistributionList.Items[?Comment=='Robert Consulting Website'].Id" \
            --output text)
          
          if [ -n "$PRODUCTION_DISTRIBUTION_ID" ]; then
            echo "ğŸ”„ Creating CloudFront invalidation for production..."
            aws cloudfront create-invalidation \
              --distribution-id $PRODUCTION_DISTRIBUTION_ID \
              --paths "/*"
            echo "âœ… Production CloudFront invalidation created"
          else
            echo "âš ï¸ Could not find production CloudFront distribution"
          fi

      - name: â³ Wait for production deployment
        run: |
          echo "â³ Waiting for production deployment to be ready..."
          sleep 30
          
          # Test production site accessibility
          for i in {1..10}; do
            if curl -f -s -I "${{ env.PRODUCTION_URL }}" > /dev/null; then
              echo "âœ… Production site is accessible"
              break
            else
              echo "â³ Waiting for production site... (attempt $i/10)"
              sleep 10
            fi
          done

      - name: ğŸ” Production validation
        run: |
          echo "ğŸ” Validating production deployment..."
          
          # Test main page
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${{ env.PRODUCTION_URL }}")
          if [ "$STATUS" != "200" ]; then
            echo "âŒ Production site returned status $STATUS"
            exit 1
          fi
          
          # Test security headers
          HEADERS=$(curl -s -I "${{ env.PRODUCTION_URL }}")
          if ! echo "$HEADERS" | grep -qi "x-frame-options"; then
            echo "âŒ Missing security headers on production"
            exit 1
          fi
          
          echo "âœ… Production deployment validated successfully"

      - name: ğŸ“Š Production deployment summary
        run: |
          echo "## ğŸš€ Production Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: âœ… Successfully deployed to production" >> $GITHUB_STEP_SUMMARY
          echo "- **Production URL**: ${{ env.PRODUCTION_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployed by**: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Timestamp**: $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "- **Validation**: âœ… All checks passed" >> $GITHUB_STEP_SUMMARY

  # Stage 5: Post-deployment monitoring
  post-deployment-monitoring:
    name: ğŸ“Š Post-deployment Monitoring
    runs-on: ubuntu-latest
    needs: deploy-to-production
    if: always() && needs.deploy-to-production.result == 'success'
    steps:
      - name: ğŸ”§ Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: ğŸ“Š Monitor deployment health
        run: |
          echo "ğŸ“Š Monitoring deployment health..."
          
          # Check CloudWatch metrics
          echo "ğŸ” Checking CloudFront metrics..."
          
          # Test production site performance
          LOAD_TIME=$(curl -s -o /dev/null -w "%{time_total}" "${{ env.PRODUCTION_URL }}")
          echo "Production load time: ${LOAD_TIME}s"
          
          # Test multiple pages
          PAGES=("" "dashboard.html" "learning.html")
          for page in "${PAGES[@]}"; do
            URL="${{ env.PRODUCTION_URL }}/$page"
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$URL")
            echo "Page $page: HTTP $STATUS"
          done
          
          echo "âœ… Post-deployment monitoring complete"

      - name: ğŸ“‹ Final deployment report
        run: |
          echo "## ğŸ“‹ Final Deployment Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### âœ… Deployment Status: SUCCESS" >> $GITHUB_STEP_SUMMARY
          echo "- **Staging**: âœ… Deployed and tested" >> $GITHUB_STEP_SUMMARY
          echo "- **Testing**: âœ… All tests passed" >> $GITHUB_STEP_SUMMARY
          echo "- **Approval**: âœ… Manually approved" >> $GITHUB_STEP_SUMMARY
          echo "- **Production**: âœ… Deployed and validated" >> $GITHUB_STEP_SUMMARY
          echo "- **Monitoring**: âœ… Health checks passed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ”— URLs:" >> $GITHUB_STEP_SUMMARY
          echo "- **Production**: ${{ env.PRODUCTION_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Staging**: ${{ env.STAGING_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ğŸ“Š Next Steps:" >> $GITHUB_STEP_SUMMARY
          echo "1. Monitor production metrics" >> $GITHUB_STEP_SUMMARY
          echo "2. Check CloudWatch dashboards" >> $GITHUB_STEP_SUMMARY
          echo "3. Verify user experience" >> $GITHUB_STEP_SUMMARY
