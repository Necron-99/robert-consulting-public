name: Staging Branch to Production Deployment (Secure)

on:
  push:
    branches: [ staging ]
    paths:
      - 'website/**'
      - 'admin/**'
      - '.github/workflows/staging-branch-deployment-secure.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'website/**'
      - 'admin/**'
  workflow_dispatch:
    inputs:
      target_branch:
        description: 'Target branch for deployment (staging or main)'
        required: false
        default: 'staging'
        type: choice
        options:
          - staging
          - main

env:
  STAGING_BUCKET: 'robert-consulting-staging-website'
  PRODUCTION_BUCKET: 'robert-consulting-website'
  STAGING_URL: 'https://staging.robertconsulting.net'
  PRODUCTION_URL: 'https://robertconsulting.net'
  STAGING_WAF_ARN: 'arn:aws:wafv2:us-east-1:228480945348:global/webacl/staging-website-waf/86f98420-79a0-4cd3-a8a5-c69d94419694'

jobs:
  # Stage 1: Deploy to Staging (from staging branch)
  deploy-to-staging:
    name: üß™ Deploy to Staging Environment
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/staging' || github.event.inputs.target_branch == 'staging'
    outputs:
      staging-deployed: ${{ steps.deploy-staging.outcome == 'success' }}
      staging-url: ${{ env.STAGING_URL }}
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîß Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: üßπ Clean and prepare staging files
        run: |
          echo "üßπ Preparing website files for staging deployment..."
          
          # Remove any test/debug files that shouldn't be deployed
          find website/ -name "*.test.*" -delete || true
          find website/ -name "*debug*" -delete || true
          find website/ -name "*temp*" -delete || true
          
          echo "‚úÖ Staging files prepared"

      - name: üöÄ Deploy website to staging S3
        id: deploy-staging
        run: |
          echo "üöÄ Deploying website content to staging S3 bucket: ${{ env.STAGING_BUCKET }}"
          
          # Use rsync with .deployignore for clean deployment
          rsync -av --exclude-from='.deployignore' website/ s3://${{ env.STAGING_BUCKET }}/ --delete
          
          echo "‚úÖ Staging deployment to S3 completed"

      - name: üîÑ Invalidate staging CloudFront cache
        run: |
          echo "üîÑ Invalidating CloudFront cache for staging..."
          
          # Get staging CloudFront distribution ID
          STAGING_DISTRIBUTION_ID="E23HB5TWK5BF44"  # Staging CloudFront distribution
          
          INVALIDATION_ID=$(aws cloudfront create-invalidation \
            --distribution-id $STAGING_DISTRIBUTION_ID \
            --paths "/*" \
            --query 'Invalidation.Id' \
            --output text)
          
          echo "‚úÖ Staging CloudFront invalidation created: $INVALIDATION_ID"

      - name: ‚è≥ Wait for staging deployment
        run: |
          echo "‚è≥ Waiting for staging deployment to be ready..."
          sleep 30
          
          # Test staging site accessibility
          for i in {1..10}; do
            if curl -f -s -I "${{ env.STAGING_URL }}" > /dev/null; then
              echo "‚úÖ Staging site is accessible"
              break
            else
              echo "‚è≥ Waiting for staging site... (attempt $i/10)"
              sleep 10
            fi
          done

  # Stage 2: Comprehensive Testing (with smart IP management)
  comprehensive-testing:
    name: üß™ Comprehensive Testing Suite
    runs-on: ubuntu-latest
    needs: [deploy-to-staging]
    if: always() && needs.deploy-to-staging.outputs.staging-deployed == 'true'
    outputs:
      tests-passed: ${{ steps.test-summary.outputs.tests-passed }}
      security-score: ${{ steps.test-summary.outputs.security-score }}
      performance-score: ${{ steps.test-summary.outputs.performance-score }}
      accessibility-score: ${{ steps.test-summary.outputs.accessibility-score }}
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîß Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: üîì Temporarily Disable IP Restrictions
        id: disable-restrictions
        run: |
          echo "üîì Temporarily disabling IP restrictions for testing..."
          
          # Update WAF to allow all traffic temporarily
          aws wafv2 update-web-acl \
            --scope CLOOUDFRONT \
            --id 86f98420-79a0-4cd3-a8a5-c69d94419694 \
            --default-action Allow={} \
            --rules file://waf-rules-temp.json || {
            echo "‚ö†Ô∏è Failed to disable restrictions, continuing with current settings"
          }
          
          echo "‚úÖ IP restrictions temporarily disabled"
          echo "restrictions-disabled=true" >> $GITHUB_OUTPUT

      - name: ‚è≥ Wait for WAF changes to propagate
        run: |
          echo "‚è≥ Waiting for WAF changes to propagate (30 seconds)..."
          sleep 30

      - name: üß™ Basic Functionality Tests
        run: |
          echo "üß™ Running basic functionality tests..."
          
          # Test main pages
          PAGES=("/" "/dashboard.html" "/learning.html" "/monitoring.html")
          FAILED_TESTS=0
          
          for page in "${PAGES[@]}"; do
            echo "Testing: ${{ env.STAGING_URL }}$page"
            if curl -f -s -I "${{ env.STAGING_URL }}$page" > /dev/null; then
              echo "‚úÖ $page - OK"
            else
              echo "‚ùå $page - FAILED"
              FAILED_TESTS=$((FAILED_TESTS + 1))
            fi
          done
          
          if [ $FAILED_TESTS -eq 0 ]; then
            echo "‚úÖ All basic functionality tests passed"
            echo "basic-tests=passed" >> $GITHUB_OUTPUT
          else
            echo "‚ùå $FAILED_TESTS basic functionality tests failed"
            echo "basic-tests=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: üîí Security Headers Test
        run: |
          echo "üîí Testing security headers..."
          
          HEADERS=$(curl -s -I "${{ env.STAGING_URL }}")
          SECURITY_HEADERS=("x-frame-options" "x-content-type-options" "strict-transport-security" "content-security-policy")
          SECURITY_SCORE=0
          TOTAL_HEADERS=${#SECURITY_HEADERS[@]}
          
          for header in "${SECURITY_HEADERS[@]}"; do
            if echo "$HEADERS" | grep -qi "$header"; then
              echo "‚úÖ $header - Present"
              SECURITY_SCORE=$((SECURITY_SCORE + 1))
            else
              echo "‚ùå $header - Missing"
            fi
          done
          
          SECURITY_PERCENTAGE=$((SECURITY_SCORE * 100 / TOTAL_HEADERS))
          echo "Security Score: $SECURITY_PERCENTAGE% ($SECURITY_SCORE/$TOTAL_HEADERS)"
          echo "security-score=$SECURITY_PERCENTAGE" >> $GITHUB_OUTPUT
          
          if [ $SECURITY_PERCENTAGE -ge 80 ]; then
            echo "‚úÖ Security headers test passed"
          else
            echo "‚ùå Security headers test failed (minimum 80% required)"
            exit 1
          fi

      - name: ‚ö° Performance Test
        run: |
          echo "‚ö° Testing performance..."
          
          # Simple performance test using curl timing
          RESPONSE_TIME=$(curl -o /dev/null -s -w '%{time_total}' "${{ env.STAGING_URL }}")
          RESPONSE_TIME_MS=$(echo "$RESPONSE_TIME * 1000" | bc -l | cut -d. -f1)
          
          echo "Response time: ${RESPONSE_TIME_MS}ms"
          
          if [ $RESPONSE_TIME_MS -lt 3000 ]; then
            echo "‚úÖ Performance test passed (${RESPONSE_TIME_MS}ms < 3000ms)"
            echo "performance-score=100" >> $GITHUB_OUTPUT
          elif [ $RESPONSE_TIME_MS -lt 5000 ]; then
            echo "‚ö†Ô∏è Performance test passed with warning (${RESPONSE_TIME_MS}ms < 5000ms)"
            echo "performance-score=80" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Performance test failed (${RESPONSE_TIME_MS}ms >= 5000ms)"
            echo "performance-score=0" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: ‚ôø Accessibility Test
        run: |
          echo "‚ôø Testing accessibility..."
          
          # Simple accessibility test - check for basic HTML structure
          CONTENT=$(curl -s "${{ env.STAGING_URL }}")
          ACCESSIBILITY_CHECKS=("alt=" "title=" "lang=" "role=")
          ACCESSIBILITY_SCORE=0
          TOTAL_CHECKS=${#ACCESSIBILITY_CHECKS[@]}
          
          for check in "${ACCESSIBILITY_CHECKS[@]}"; do
            if echo "$CONTENT" | grep -q "$check"; then
              echo "‚úÖ $check - Present"
              ACCESSIBILITY_SCORE=$((ACCESSIBILITY_SCORE + 1))
            else
              echo "‚ùå $check - Missing"
            fi
          done
          
          ACCESSIBILITY_PERCENTAGE=$((ACCESSIBILITY_SCORE * 100 / TOTAL_CHECKS))
          echo "Accessibility Score: $ACCESSIBILITY_PERCENTAGE% ($ACCESSIBILITY_SCORE/$TOTAL_CHECKS)"
          echo "accessibility-score=$ACCESSIBILITY_PERCENTAGE" >> $GITHUB_OUTPUT
          
          if [ $ACCESSIBILITY_PERCENTAGE -ge 60 ]; then
            echo "‚úÖ Accessibility test passed"
          else
            echo "‚ùå Accessibility test failed (minimum 60% required)"
            exit 1
          fi

      - name: üîó Content Validation Test
        run: |
          echo "üîó Testing content validation..."
          
          # Check for broken internal links
          CONTENT=$(curl -s "${{ env.STAGING_URL }}")
          INTERNAL_LINKS=$(echo "$CONTENT" | grep -o 'href="[^"]*"' | grep -v 'http' | grep -v 'mailto:' | grep -v 'tel:' | wc -l)
          
          echo "Found $INTERNAL_LINKS internal links"
          
          if [ $INTERNAL_LINKS -gt 0 ]; then
            echo "‚úÖ Content validation test passed"
          else
            echo "‚ö†Ô∏è No internal links found (may be normal for simple pages)"
          fi

      - name: üîí Re-enable IP Restrictions
        id: enable-restrictions
        if: always()
        run: |
          echo "üîí Re-enabling IP restrictions..."
          
          # Re-enable IP restrictions by updating WAF back to block default
          aws wafv2 update-web-acl \
            --scope CLOOUDFRONT \
            --id 86f98420-79a0-4cd3-a8a5-c69d94419694 \
            --default-action Block={} \
            --rules file://waf-rules-original.json || {
            echo "‚ö†Ô∏è Failed to re-enable restrictions via API, using Terraform fallback"
            
            # Fallback: Use Terraform to re-enable restrictions
            cd terraform
            terraform apply -target=aws_wafv2_web_acl.staging_waf -auto-approve
          }
          
          echo "‚úÖ IP restrictions re-enabled"
          echo "restrictions-enabled=true" >> $GITHUB_OUTPUT

      - name: üìä Test Summary
        id: test-summary
        run: |
          echo "üìä Test Summary:"
          echo "- Basic Functionality: ${{ steps.basic-tests.outputs.basic-tests || 'unknown' }}"
          echo "- Security Score: ${{ steps.security-test.outputs.security-score || 'unknown' }}%"
          echo "- Performance Score: ${{ steps.performance-test.outputs.performance-score || 'unknown' }}%"
          echo "- Accessibility Score: ${{ steps.accessibility-test.outputs.accessibility-score || 'unknown' }}%"
          
          # Determine overall test result
          if [ "${{ steps.basic-tests.outputs.basic-tests }}" = "passed" ] && \
             [ "${{ steps.security-test.outputs.security-score }}" -ge 80 ] && \
             [ "${{ steps.performance-test.outputs.performance-score }}" -ge 60 ] && \
             [ "${{ steps.accessibility-test.outputs.accessibility-score }}" -ge 60 ]; then
            echo "‚úÖ All tests passed - ready for production deployment"
            echo "tests-passed=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Some tests failed - not ready for production deployment"
            echo "tests-passed=false" >> $GITHUB_OUTPUT
          fi

  # Stage 3: Automated Production Deployment (when all tests pass)
  automated-production-deployment:
    name: ü§ñ Automated Production Deployment
    runs-on: ubuntu-latest
    needs: [deploy-to-staging, comprehensive-testing]
    if: needs.comprehensive-testing.result == 'success'
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: ü§ñ Automated Approval - Merge Staging to Main
        run: |
          echo "ü§ñ Automated approval triggered by comprehensive testing results"
          echo "All deployment criteria met:"
          echo "- Security Score: ${{ needs.comprehensive-testing.outputs.security-score }}% (‚â•80% required)"
          echo "- Performance Score: ${{ needs.comprehensive-testing.outputs.performance-score }}% (‚â•60% required)"
          echo "- Accessibility Score: ${{ needs.comprehensive-testing.outputs.accessibility-score }}% (‚â•60% required)"
          echo ""
          echo "Merging staging branch to main for production deployment..."
          
          # Configure git
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          # Fetch all branches
          git fetch origin
          
          # Switch to main branch
          git checkout main
          git pull origin main
          
          # Force push staging branch to main (staging is the source of truth)
          git push origin staging:main --force
          
          echo "‚úÖ Staging branch merged to main successfully"

      - name: üîß Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: üßπ Clean and prepare production files
        run: |
          echo "üßπ Preparing website files for production deployment..."
          
          # Remove any test/debug files that shouldn't be deployed
          find website/ -name "*.test.*" -delete || true
          find website/ -name "*debug*" -delete || true
          find website/ -name "*temp*" -delete || true
          
          echo "‚úÖ Production files prepared"

      - name: üöÄ Deploy website to production S3
        run: |
          echo "üöÄ Deploying website content to production S3 bucket: ${{ env.PRODUCTION_BUCKET }}"
          
          # Use rsync with .deployignore for clean deployment
          rsync -av --exclude-from='.deployignore' website/ s3://${{ env.PRODUCTION_BUCKET }}/ --delete
          
          echo "‚úÖ Production deployment to S3 completed"

      - name: üîÑ Invalidate production CloudFront cache
        run: |
          echo "üîÑ Invalidating CloudFront cache for production..."
          
          # Get production CloudFront distribution ID
          PRODUCTION_DISTRIBUTION_ID="E36DBYPHUUKB3V"  # Main production CloudFront distribution
          
          INVALIDATION_ID=$(aws cloudfront create-invalidation \
            --distribution-id $PRODUCTION_DISTRIBUTION_ID \
            --paths "/*" \
            --query 'Invalidation.Id' \
            --output text)
          
          echo "‚úÖ Production CloudFront invalidation created: $INVALIDATION_ID"

      - name: ‚è≥ Wait for production deployment
        run: |
          echo "‚è≥ Waiting for production deployment to be ready..."
          sleep 30
          
          # Test production site accessibility
          for i in {1..10}; do
            if curl -f -s -I "${{ env.PRODUCTION_URL }}" > /dev/null; then
              echo "‚úÖ Production site is accessible"
              break
            else
              echo "‚è≥ Waiting for production site... (attempt $i/10)"
              sleep 10
            fi
          done

      - name: üîç Production validation
        run: |
          echo "üîç Validating production deployment..."
          
          # Test main page
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${{ env.PRODUCTION_URL }}")
          if [ "$STATUS" != "200" ]; then
            echo "‚ùå Production site returned status $STATUS"
            exit 1
          fi
          
          # Test security headers
          HEADERS=$(curl -s -I "${{ env.PRODUCTION_URL }}")
          if ! echo "$HEADERS" | grep -qi "x-frame-options"; then
            echo "‚ùå Missing security headers on production"
            exit 1
          fi
          
          echo "‚úÖ Production deployment validated successfully"

      - name: üìä Automated Production Deployment Summary
        run: |
          echo "## ü§ñ Automated Production Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ‚úÖ Successfully deployed to production via automated approval" >> $GITHUB_STEP_SUMMARY
          echo "- **Production URL**: ${{ env.PRODUCTION_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployed by**: GitHub Actions (Automated)" >> $GITHUB_STEP_SUMMARY
          echo "- **Timestamp**: $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "- **Validation**: ‚úÖ All comprehensive tests passed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üß™ Test Scores That Triggered Auto-Deployment:" >> $GITHUB_STEP_SUMMARY
          echo "- **Security Score**: ${{ needs.comprehensive-testing.outputs.security-score }}% (‚â•80% required)" >> $GITHUB_STEP_SUMMARY
          echo "- **Performance Score**: ${{ needs.comprehensive-testing.outputs.performance-score }}% (‚â•60% required)" >> $GITHUB_STEP_SUMMARY
          echo "- **Accessibility Score**: ${{ needs.comprehensive-testing.outputs.accessibility-score }}% (‚â•60% required)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üéØ Automated Deployment Benefits:" >> $GITHUB_STEP_SUMMARY
          echo "- **Zero manual intervention required**" >> $GITHUB_STEP_SUMMARY
          echo "- **Comprehensive quality assurance**" >> $GITHUB_STEP_SUMMARY
          echo "- **Consistent deployment process**" >> $GITHUB_STEP_SUMMARY
          echo "- **Full audit trail maintained**" >> $GITHUB_STEP_SUMMARY
