name: Staging Branch to Production Deployment

on:
  push:
    branches: [ staging ]
    paths:
      - 'website/**'
      - 'admin/**'
      - '.github/workflows/staging-branch-deployment.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'website/**'
      - 'admin/**'
  workflow_dispatch:
    inputs:
      target_branch:
        description: 'Target branch for deployment (staging or main)'
        required: false
        default: 'staging'
        type: choice
        options:
          - staging
          - main

env:
  STAGING_BUCKET: 'robert-consulting-staging-website'
  PRODUCTION_BUCKET: 'robert-consulting-website'
  STAGING_URL: 'https://staging.robertconsulting.net'
  PRODUCTION_URL: 'https://robertconsulting.net'

jobs:
  # Stage 1: Deploy to Staging (from staging branch)
  deploy-to-staging:
    name: ğŸ§ª Deploy to Staging Environment
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/staging' || github.event.inputs.target_branch == 'staging'
    outputs:
      staging-deployed: ${{ steps.deploy-staging.outcome == 'success' }}
      staging-url: ${{ env.STAGING_URL }}
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ”§ Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: ğŸ§¹ Clean and prepare website files
        run: |
          echo "ğŸ§¹ Preparing website files for staging deployment..."
          
          # Remove any test/debug files that shouldn't be deployed
          find website/ -name "*.test.*" -delete || true
          find website/ -name "*debug*" -delete || true
          find website/ -name "*temp*" -delete || true
          
          # Ensure proper file permissions
          find website/ -type f -name "*.html" -exec chmod 644 {} \;
          find website/ -type f -name "*.css" -exec chmod 644 {} \;
          find website/ -type f -name "*.js" -exec chmod 644 {} \;
          
          echo "âœ… Website files prepared for staging"

      - name: ğŸš€ Deploy website to staging
        id: deploy-staging
        run: |
          echo "ğŸš€ Deploying website to staging environment..."
          
          # Sync website files to staging bucket
          aws s3 sync website/ s3://${{ env.STAGING_BUCKET }} \
            --delete \
            --exclude "*.tf" \
            --exclude "*.tfvars" \
            --exclude "*.tfstate*" \
            --exclude "terraform/" \
            --exclude "backup/" \
            --exclude "*.test.*" \
            --exclude "*debug*" \
            --exclude "*temp*" \
            --cache-control "public, max-age=3600" \
            --metadata "deployment=staging,commit=${{ github.sha }}"
          
          echo "âœ… Website deployed to staging S3 bucket"
          
          # Create CloudFront invalidation for staging
          STAGING_DISTRIBUTION_ID=$(aws cloudfront list-distributions \
            --query "DistributionList.Items[?Comment=='Robert Consulting Staging Website'].Id" \
            --output text)
          
          if [ -n "$STAGING_DISTRIBUTION_ID" ]; then
            echo "ğŸ”„ Creating CloudFront invalidation for staging..."
            aws cloudfront create-invalidation \
              --distribution-id $STAGING_DISTRIBUTION_ID \
              --paths "/*"
            echo "âœ… Staging CloudFront invalidation created"
          else
            echo "âš ï¸ Could not find staging CloudFront distribution"
          fi

      - name: â³ Wait for staging deployment
        run: |
          echo "â³ Waiting for staging deployment to be ready..."
          sleep 30
          
          # Test staging site accessibility
          for i in {1..10}; do
            if curl -f -s -I "${{ env.STAGING_URL }}" > /dev/null; then
              echo "âœ… Staging site is accessible"
              break
            else
              echo "â³ Waiting for staging site... (attempt $i/10)"
              sleep 10
            fi
          done

      - name: ğŸ“Š Staging deployment summary
        run: |
          echo "## ğŸ§ª Staging Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: âœ… Successfully deployed to staging" >> $GITHUB_STEP_SUMMARY
          echo "- **Staging URL**: ${{ env.STAGING_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: \`${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployed by**: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Timestamp**: $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ğŸ”„ Next Steps:" >> $GITHUB_STEP_SUMMARY
          echo "1. **Review staging site**: Visit ${{ env.STAGING_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "2. **Create PR to main**: When ready for production" >> $GITHUB_STEP_SUMMARY
          echo "3. **Manual approval required**: Production deployment needs approval" >> $GITHUB_STEP_SUMMARY

  # Stage 2: Comprehensive Testing (on staging branch)
  comprehensive-testing:
    name: ğŸ§ª Comprehensive Test Battery
    runs-on: ubuntu-latest
    needs: deploy-to-staging
    if: github.ref == 'refs/heads/staging' || github.event.inputs.target_branch == 'staging'
    outputs:
      tests-passed: ${{ steps.test-summary.outcome == 'success' }}
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ”§ Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: ğŸ§ª Test 1 - Basic Functionality Tests
        run: |
          echo "ğŸ§ª Running basic functionality tests..."
          
          # Test main pages
          PAGES=("" "dashboard.html" "learning.html" "monitoring.html" "best-practices.html")
          
          for page in "${PAGES[@]}"; do
            URL="${{ env.STAGING_URL }}/$page"
            echo "Testing: $URL"
            
            # Test HTTP status
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$URL")
            if [ "$STATUS" != "200" ]; then
              echo "âŒ Failed: $URL returned status $STATUS"
              exit 1
            fi
            
            # Test content presence
            if ! curl -s "$URL" | grep -q "<!DOCTYPE html>"; then
              echo "âŒ Failed: $URL missing DOCTYPE"
              exit 1
            fi
            
            echo "âœ… $URL passed basic tests"
          done
          
          echo "âœ… All basic functionality tests passed"

      - name: ğŸ›¡ï¸ Test 2 - Security Headers Validation
        run: |
          echo "ğŸ›¡ï¸ Validating security headers..."
          
          # Test security headers on main page
          HEADERS=$(curl -s -I "${{ env.STAGING_URL }}")
          
          REQUIRED_HEADERS=(
            "x-frame-options: DENY"
            "referrer-policy: strict-origin-when-cross-origin"
            "content-security-policy:"
            "strict-transport-security:"
            "x-content-type-options:"
          )
          
          for header in "${REQUIRED_HEADERS[@]}"; do
            if ! echo "$HEADERS" | grep -qi "$header"; then
              echo "âŒ Missing security header: $header"
              exit 1
            fi
            echo "âœ… Found security header: $header"
          done
          
          echo "âœ… All security headers present"

      - name: ğŸ“Š Test Summary
        id: test-summary
        run: |
          echo "## ğŸ§ª Comprehensive Test Results" >> $GITHUB_STEP_SUMMARY
          echo "- **Basic Functionality**: âœ… Passed" >> $GITHUB_STEP_SUMMARY
          echo "- **Security Headers**: âœ… Passed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**All tests passed!** Ready for production deployment." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ğŸ”„ Next Steps:" >> $GITHUB_STEP_SUMMARY
          echo "1. **Review staging site**: Visit ${{ env.STAGING_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "2. **Create PR to main**: When ready for production" >> $GITHUB_STEP_SUMMARY
          echo "3. **Manual approval required**: Production deployment needs approval" >> $GITHUB_STEP_SUMMARY

  # Stage 3: Production Deployment (only on main branch merge)
  deploy-to-production:
    name: ğŸš€ Deploy to Production
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' || github.event.inputs.target_branch == 'main'
    environment: 
      name: production-deployment
      url: https://robertconsulting.net
    steps:
      - name: ğŸ“¥ Checkout code
        uses: actions/checkout@v4

      - name: ğŸ”§ Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: ğŸ§¹ Clean and prepare production files
        run: |
          echo "ğŸ§¹ Preparing website files for production deployment..."
          
          # Remove any test/debug files that shouldn't be deployed
          find website/ -name "*.test.*" -delete || true
          find website/ -name "*debug*" -delete || true
          find website/ -name "*temp*" -delete || true
          
          # Ensure proper file permissions
          find website/ -type f -name "*.html" -exec chmod 644 {} \;
          find website/ -type f -name "*.css" -exec chmod 644 {} \;
          find website/ -type f -name "*.js" -exec chmod 644 {} \;
          
          echo "âœ… Website files prepared for production"

      - name: ğŸš€ Deploy website to production
        run: |
          echo "ğŸš€ Deploying website to production environment..."
          
          # Sync website files to production bucket
          aws s3 sync website/ s3://${{ env.PRODUCTION_BUCKET }} \
            --delete \
            --exclude "*.tf" \
            --exclude "*.tfvars" \
            --exclude "*.tfstate*" \
            --exclude "terraform/" \
            --exclude "backup/" \
            --exclude "*.test.*" \
            --exclude "*debug*" \
            --exclude "*temp*" \
            --cache-control "public, max-age=3600" \
            --metadata "deployment=production,commit=${{ github.sha }}"
          
          echo "âœ… Website deployed to production S3 bucket"
          
          # Create CloudFront invalidation for production
          PRODUCTION_DISTRIBUTION_ID=$(aws cloudfront list-distributions \
            --query "DistributionList.Items[?Comment=='Robert Consulting Website'].Id" \
            --output text)
          
          if [ -n "$PRODUCTION_DISTRIBUTION_ID" ]; then
            echo "ğŸ”„ Creating CloudFront invalidation for production..."
            aws cloudfront create-invalidation \
              --distribution-id $PRODUCTION_DISTRIBUTION_ID \
              --paths "/*"
            echo "âœ… Production CloudFront invalidation created"
          else
            echo "âš ï¸ Could not find production CloudFront distribution"
          fi

      - name: â³ Wait for production deployment
        run: |
          echo "â³ Waiting for production deployment to be ready..."
          sleep 30
          
          # Test production site accessibility
          for i in {1..10}; do
            if curl -f -s -I "${{ env.PRODUCTION_URL }}" > /dev/null; then
              echo "âœ… Production site is accessible"
              break
            else
              echo "â³ Waiting for production site... (attempt $i/10)"
              sleep 10
            fi
          done

      - name: ğŸ” Production validation
        run: |
          echo "ğŸ” Validating production deployment..."
          
          # Test main page
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${{ env.PRODUCTION_URL }}")
          if [ "$STATUS" != "200" ]; then
            echo "âŒ Production site returned status $STATUS"
            exit 1
          fi
          
          # Test security headers
          HEADERS=$(curl -s -I "${{ env.PRODUCTION_URL }}")
          if ! echo "$HEADERS" | grep -qi "x-frame-options"; then
            echo "âŒ Missing security headers on production"
            exit 1
          fi
          
          echo "âœ… Production deployment validated successfully"

      - name: ğŸ“Š Production deployment summary
        run: |
          echo "## ğŸš€ Production Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: âœ… Successfully deployed to production" >> $GITHUB_STEP_SUMMARY
          echo "- **Production URL**: ${{ env.PRODUCTION_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployed by**: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Timestamp**: $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "- **Validation**: âœ… All checks passed" >> $GITHUB_STEP_SUMMARY
