name: Staging Branch to Production Deployment

on:
  push:
    branches: [ staging ]
    paths:
      - 'website/**'
      - 'admin/**'
      - '.github/workflows/staging-branch-deployment.yml'
  pull_request:
    branches: [ main ]
    paths:
      - 'website/**'
      - 'admin/**'
  workflow_dispatch:
    inputs:
      target_branch:
        description: 'Target branch for deployment (staging or main)'
        required: false
        default: 'staging'
        type: choice
        options:
          - staging
          - main

env:
  STAGING_BUCKET: 'robert-consulting-staging-website'
  PRODUCTION_BUCKET: 'robert-consulting-website'
  STAGING_URL: 'https://staging.robertconsulting.net'
  PRODUCTION_URL: 'https://robertconsulting.net'

jobs:
  # Stage 1: Deploy to Staging (from staging branch)
  deploy-to-staging:
    name: üß™ Deploy to Staging Environment
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/staging' || github.event.inputs.target_branch == 'staging'
    outputs:
      staging-deployed: ${{ steps.deploy-staging.outcome == 'success' }}
      staging-url: ${{ env.STAGING_URL }}
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîß Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: üßπ Clean and prepare website files
        run: |
          echo "üßπ Preparing website files for staging deployment..."
          
          # Remove any test/debug files that shouldn't be deployed
          find website/ -name "*.test.*" -delete || true
          find website/ -name "*debug*" -delete || true
          find website/ -name "*temp*" -delete || true
          
          # Ensure proper file permissions
          find website/ -type f -name "*.html" -exec chmod 644 {} \;
          find website/ -type f -name "*.css" -exec chmod 644 {} \;
          find website/ -type f -name "*.js" -exec chmod 644 {} \;
          
          echo "‚úÖ Website files prepared for staging"

      - name: üöÄ Deploy website to staging
        id: deploy-staging
        run: |
          echo "üöÄ Deploying website to staging environment..."
          
          # Sync website files to staging bucket
          aws s3 sync website/ s3://${{ env.STAGING_BUCKET }} \
            --delete \
            --exclude "*.tf" \
            --exclude "*.tfvars" \
            --exclude "*.tfstate*" \
            --exclude "terraform/" \
            --exclude "backup/" \
            --exclude "*.test.*" \
            --exclude "*debug*" \
            --exclude "*temp*" \
            --cache-control "public, max-age=3600" \
            --metadata "deployment=staging,commit=${{ github.sha }}"
          
          echo "‚úÖ Website deployed to staging S3 bucket"
          
          # Create CloudFront invalidation for staging
          STAGING_DISTRIBUTION_ID=$(aws cloudfront list-distributions \
            --query "DistributionList.Items[?Comment=='Robert Consulting Staging Website'].Id" \
            --output text)
          
          if [ -n "$STAGING_DISTRIBUTION_ID" ]; then
            echo "üîÑ Creating CloudFront invalidation for staging..."
            aws cloudfront create-invalidation \
              --distribution-id $STAGING_DISTRIBUTION_ID \
              --paths "/*"
            echo "‚úÖ Staging CloudFront invalidation created"
          else
            echo "‚ö†Ô∏è Could not find staging CloudFront distribution"
          fi

      - name: ‚è≥ Wait for staging deployment
        run: |
          echo "‚è≥ Waiting for staging deployment to be ready..."
          sleep 30
          
          # Test staging site accessibility
          for i in {1..10}; do
            if curl -f -s -I "${{ env.STAGING_URL }}" > /dev/null; then
              echo "‚úÖ Staging site is accessible"
              break
            else
              echo "‚è≥ Waiting for staging site... (attempt $i/10)"
              sleep 10
            fi
          done

      - name: üìä Staging deployment summary
        run: |
          echo "## üß™ Staging Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ‚úÖ Successfully deployed to staging" >> $GITHUB_STEP_SUMMARY
          echo "- **Staging URL**: ${{ env.STAGING_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: \`${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployed by**: ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Timestamp**: $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üîÑ Next Steps:" >> $GITHUB_STEP_SUMMARY
          echo "1. **Review staging site**: Visit ${{ env.STAGING_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "2. **Create PR to main**: When ready for production" >> $GITHUB_STEP_SUMMARY
          echo "3. **Manual approval required**: Production deployment needs approval" >> $GITHUB_STEP_SUMMARY

  # Stage 2: Comprehensive Testing Suite (on staging branch)
  comprehensive-testing:
    name: üß™ Comprehensive Test Battery
    runs-on: ubuntu-latest
    needs: deploy-to-staging
    if: github.ref == 'refs/heads/staging' || github.event.inputs.target_branch == 'staging'
    outputs:
      tests-passed: ${{ steps.test-summary.outcome == 'success' }}
      security-score: ${{ steps.security-test.outputs.score }}
      performance-score: ${{ steps.performance-test.outputs.score }}
      accessibility-score: ${{ steps.accessibility-test.outputs.score }}
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîß Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: üß™ Test 1 - Basic Functionality Tests
        run: |
          echo "üß™ Running basic functionality tests..."
          
          # Test main pages
          PAGES=("" "dashboard.html" "learning.html" "monitoring.html" "best-practices.html")
          
          for page in "${PAGES[@]}"; do
            URL="${{ env.STAGING_URL }}/$page"
            echo "Testing: $URL"
            
            # Test HTTP status
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" "$URL")
            if [ "$STATUS" != "200" ]; then
              echo "‚ùå Failed: $URL returned status $STATUS"
              exit 1
            fi
            
            # Test content presence
            if ! curl -s "$URL" | grep -q "<!DOCTYPE html>"; then
              echo "‚ùå Failed: $URL missing DOCTYPE"
              exit 1
            fi
            
            # Test for basic HTML structure
            if ! curl -s "$URL" | grep -q "<html"; then
              echo "‚ùå Failed: $URL missing HTML tag"
              exit 1
            fi
            
            # Test for title tag
            if ! curl -s "$URL" | grep -q "<title"; then
              echo "‚ùå Failed: $URL missing title tag"
              exit 1
            fi
            
            echo "‚úÖ $URL passed basic tests"
          done
          
          echo "‚úÖ All basic functionality tests passed"

      - name: üõ°Ô∏è Test 2 - Security Headers Validation
        id: security-test
        run: |
          echo "üõ°Ô∏è Validating security headers..."
          
          # Test security headers on main page
          HEADERS=$(curl -s -I "${{ env.STAGING_URL }}")
          
          REQUIRED_HEADERS=(
            "x-frame-options: DENY"
            "referrer-policy: strict-origin-when-cross-origin"
            "content-security-policy:"
            "strict-transport-security:"
            "x-content-type-options:"
          )
          
          SECURITY_SCORE=0
          TOTAL_HEADERS=${#REQUIRED_HEADERS[@]}
          
          for header in "${REQUIRED_HEADERS[@]}"; do
            if echo "$HEADERS" | grep -qi "$header"; then
              echo "‚úÖ Found security header: $header"
              SECURITY_SCORE=$((SECURITY_SCORE + 1))
            else
              echo "‚ùå Missing security header: $header"
            fi
          done
          
          # Calculate percentage
          SECURITY_PERCENTAGE=$((SECURITY_SCORE * 100 / TOTAL_HEADERS))
          echo "security-score=$SECURITY_PERCENTAGE" >> $GITHUB_OUTPUT
          
          if [ $SECURITY_SCORE -eq $TOTAL_HEADERS ]; then
            echo "‚úÖ All security headers present (Score: $SECURITY_PERCENTAGE%)"
          else
            echo "‚ö†Ô∏è Security headers incomplete (Score: $SECURITY_PERCENTAGE%)"
            if [ $SECURITY_PERCENTAGE -lt 80 ]; then
              echo "‚ùå Security score too low for production deployment"
              exit 1
            fi
          fi

      - name: üöÄ Test 3 - Performance Testing
        id: performance-test
        run: |
          echo "üöÄ Running performance tests..."
          
          # Test page load times
          PAGES=("" "dashboard.html" "learning.html")
          TOTAL_LOAD_TIME=0
          PAGE_COUNT=0
          
          for page in "${PAGES[@]}"; do
            URL="${{ env.STAGING_URL }}/$page"
            echo "Testing performance: $URL"
            
            # Measure load time
            LOAD_TIME=$(curl -o /dev/null -s -w "%{time_total}\n" "$URL")
            echo "Load time: ${LOAD_TIME}s"
            
            TOTAL_LOAD_TIME=$(echo "$TOTAL_LOAD_TIME + $LOAD_TIME" | bc -l)
            PAGE_COUNT=$((PAGE_COUNT + 1))
            
            # Fail if load time is too high
            if (( $(echo "$LOAD_TIME > 5.0" | bc -l) )); then
              echo "‚ùå Performance test failed: Load time too high (${LOAD_TIME}s)"
              exit 1
            fi
          done
          
          # Calculate average load time
          AVG_LOAD_TIME=$(echo "scale=2; $TOTAL_LOAD_TIME / $PAGE_COUNT" | bc -l)
          echo "Average load time: ${AVG_LOAD_TIME}s"
          
          # Calculate performance score (100 - (avg_time * 20))
          PERFORMANCE_SCORE=$(echo "100 - ($AVG_LOAD_TIME * 20)" | bc -l | cut -d. -f1)
          if [ $PERFORMANCE_SCORE -lt 0 ]; then
            PERFORMANCE_SCORE=0
          fi
          
          echo "performance-score=$PERFORMANCE_SCORE" >> $GITHUB_OUTPUT
          
          if [ $PERFORMANCE_SCORE -ge 80 ]; then
            echo "‚úÖ Performance test passed (Score: $PERFORMANCE_SCORE%)"
          else
            echo "‚ö†Ô∏è Performance score low (Score: $PERFORMANCE_SCORE%)"
            if [ $PERFORMANCE_SCORE -lt 60 ]; then
              echo "‚ùå Performance score too low for production deployment"
              exit 1
            fi
          fi

      - name: ‚ôø Test 4 - Accessibility Testing
        id: accessibility-test
        run: |
          echo "‚ôø Running accessibility tests..."
          
          # Test for basic accessibility features
          URL="${{ env.STAGING_URL }}"
          CONTENT=$(curl -s "$URL")
          
          ACCESSIBILITY_SCORE=0
          TOTAL_CHECKS=8
          
          # Check for alt attributes on images
          if echo "$CONTENT" | grep -q 'alt='; then
            echo "‚úÖ Found alt attributes on images"
            ACCESSIBILITY_SCORE=$((ACCESSIBILITY_SCORE + 1))
          else
            echo "‚ö†Ô∏è No alt attributes found on images"
          fi
          
          # Check for heading structure
          if echo "$CONTENT" | grep -q '<h1'; then
            echo "‚úÖ Found H1 heading"
            ACCESSIBILITY_SCORE=$((ACCESSIBILITY_SCORE + 1))
          else
            echo "‚ö†Ô∏è No H1 heading found"
          fi
          
          # Check for form labels
          if echo "$CONTENT" | grep -q '<label'; then
            echo "‚úÖ Found form labels"
            ACCESSIBILITY_SCORE=$((ACCESSIBILITY_SCORE + 1))
          else
            echo "‚ÑπÔ∏è No forms found (not applicable)"
            ACCESSIBILITY_SCORE=$((ACCESSIBILITY_SCORE + 1)) # Not applicable
          fi
          
          # Check for semantic HTML
          if echo "$CONTENT" | grep -q '<nav\|<main\|<header\|<footer'; then
            echo "‚úÖ Found semantic HTML elements"
            ACCESSIBILITY_SCORE=$((ACCESSIBILITY_SCORE + 1))
          else
            echo "‚ö†Ô∏è Limited semantic HTML usage"
          fi
          
          # Check for proper contrast (basic check)
          if echo "$CONTENT" | grep -q 'color:\|background-color:'; then
            echo "‚úÖ Found color definitions"
            ACCESSIBILITY_SCORE=$((ACCESSIBILITY_SCORE + 1))
          else
            echo "‚ÑπÔ∏è Using default colors"
            ACCESSIBILITY_SCORE=$((ACCESSIBILITY_SCORE + 1)) # Default is usually fine
          fi
          
          # Check for keyboard navigation
          if echo "$CONTENT" | grep -q 'tabindex\|onclick'; then
            echo "‚úÖ Found interactive elements"
            ACCESSIBILITY_SCORE=$((ACCESSIBILITY_SCORE + 1))
          else
            echo "‚ÑπÔ∏è Limited interactive elements"
            ACCESSIBILITY_SCORE=$((ACCESSIBILITY_SCORE + 1)) # Not applicable
          fi
          
          # Check for meta viewport
          if echo "$CONTENT" | grep -q 'viewport'; then
            echo "‚úÖ Found viewport meta tag"
            ACCESSIBILITY_SCORE=$((ACCESSIBILITY_SCORE + 1))
          else
            echo "‚ö†Ô∏è Missing viewport meta tag"
          fi
          
          # Check for language attribute
          if echo "$CONTENT" | grep -q 'lang='; then
            echo "‚úÖ Found language attribute"
            ACCESSIBILITY_SCORE=$((ACCESSIBILITY_SCORE + 1))
          else
            echo "‚ö†Ô∏è Missing language attribute"
          fi
          
          # Calculate percentage
          ACCESSIBILITY_PERCENTAGE=$((ACCESSIBILITY_SCORE * 100 / TOTAL_CHECKS))
          echo "accessibility-score=$ACCESSIBILITY_PERCENTAGE" >> $GITHUB_OUTPUT
          
          if [ $ACCESSIBILITY_PERCENTAGE -ge 80 ]; then
            echo "‚úÖ Accessibility test passed (Score: $ACCESSIBILITY_PERCENTAGE%)"
          else
            echo "‚ö†Ô∏è Accessibility score low (Score: $ACCESSIBILITY_PERCENTAGE%)"
            if [ $ACCESSIBILITY_PERCENTAGE -lt 60 ]; then
              echo "‚ùå Accessibility score too low for production deployment"
              exit 1
            fi
          fi

      - name: üîó Test 5 - Content Validation
        run: |
          echo "üîó Running content validation tests..."
          
          # Test for broken internal links (basic check)
          URL="${{ env.STAGING_URL }}"
          CONTENT=$(curl -s "$URL")
          
          # Check for common broken link patterns
          if echo "$CONTENT" | grep -q 'href="mailto:'; then
            echo "‚úÖ Found email links"
          fi
          
          if echo "$CONTENT" | grep -q 'href="https://'; then
            echo "‚úÖ Found external links"
          fi
          
          # Check for proper meta tags
          if echo "$CONTENT" | grep -q '<meta name="description"'; then
            echo "‚úÖ Found meta description"
          else
            echo "‚ö†Ô∏è Missing meta description"
          fi
          
          if echo "$CONTENT" | grep -q '<meta name="keywords"'; then
            echo "‚úÖ Found meta keywords"
          else
            echo "‚ö†Ô∏è Missing meta keywords"
          fi
          
          # Check for proper title
          if echo "$CONTENT" | grep -q '<title>'; then
            echo "‚úÖ Found page title"
          else
            echo "‚ùå Missing page title"
            exit 1
          fi
          
          echo "‚úÖ Content validation tests passed"

      - name: üîí Test 6 - OWASP ZAP Security Scan
        run: |
          echo "üîí Running OWASP ZAP security scan..."
          
          # Run a quick ZAP baseline scan
          docker run -v $(pwd):/zap/wrk/:rw -t owasp/zap2docker-stable zap-baseline.py \
            -t "${{ env.STAGING_URL }}" \
            -J zap-report.json \
            -x zap-report.xml \
            -r zap-report.html \
            -a || true
          
          # Check if high/critical issues were found
          if [ -f zap-report.json ]; then
            HIGH_ISSUES=$(jq '.High // 0' zap-report.json)
            CRITICAL_ISSUES=$(jq '.Critical // 0' zap-report.json)
            
            echo "Security scan results:"
            echo "- Critical issues: $CRITICAL_ISSUES"
            echo "- High issues: $HIGH_ISSUES"
            
            if [ "$CRITICAL_ISSUES" -gt 0 ] || [ "$HIGH_ISSUES" -gt 2 ]; then
              echo "‚ùå Too many security issues found for production deployment"
              exit 1
            else
              echo "‚úÖ Security scan passed"
            fi
          else
            echo "‚ö†Ô∏è Security scan report not generated"
          fi

      - name: üìä Test Summary
        id: test-summary
        run: |
          echo "## üß™ Comprehensive Test Results" >> $GITHUB_STEP_SUMMARY
          echo "- **Basic Functionality**: ‚úÖ Passed" >> $GITHUB_STEP_SUMMARY
          echo "- **Security Headers**: ‚úÖ Score: ${{ steps.security-test.outputs.security-score }}%" >> $GITHUB_STEP_SUMMARY
          echo "- **Performance**: ‚úÖ Score: ${{ steps.performance-test.outputs.performance-score }}%" >> $GITHUB_STEP_SUMMARY
          echo "- **Accessibility**: ‚úÖ Score: ${{ steps.accessibility-test.outputs.accessibility-score }}%" >> $GITHUB_STEP_SUMMARY
          echo "- **Content Validation**: ‚úÖ Passed" >> $GITHUB_STEP_SUMMARY
          echo "- **Security Scan**: ‚úÖ Passed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**All tests passed!** Ready for automated production deployment." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## ü§ñ Automated Deployment Criteria:" >> $GITHUB_STEP_SUMMARY
          echo "- Security Score: ${{ steps.security-test.outputs.security-score }}% (‚â•80% required)" >> $GITHUB_STEP_SUMMARY
          echo "- Performance Score: ${{ steps.performance-test.outputs.performance-score }}% (‚â•60% required)" >> $GITHUB_STEP_SUMMARY
          echo "- Accessibility Score: ${{ steps.accessibility-test.outputs.accessibility-score }}% (‚â•60% required)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üîÑ Next Steps:" >> $GITHUB_STEP_SUMMARY
          echo "1. **Review staging site**: Visit ${{ env.STAGING_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "2. **Automated approval**: All criteria met for auto-deployment" >> $GITHUB_STEP_SUMMARY
          echo "3. **Production deployment**: Ready for automated deployment" >> $GITHUB_STEP_SUMMARY

  # Stage 3: Automated Production Deployment (when all tests pass)
  automated-production-deployment:
    name: ü§ñ Automated Production Deployment
    runs-on: ubuntu-latest
    needs: [deploy-to-staging, comprehensive-testing]
    if: needs.comprehensive-testing.result == 'success'
    permissions:
      contents: write
      pull-requests: write
    # Environment protection removed for automated deployment
    # url: https://robertconsulting.net
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: ü§ñ Automated Approval - Merge Staging to Main
        run: |
          echo "ü§ñ Automated approval triggered by comprehensive testing results"
          echo "All deployment criteria met:"
          echo "- Security Score: ${{ needs.comprehensive-testing.outputs.security-score }}% (‚â•80% required)"
          echo "- Performance Score: ${{ needs.comprehensive-testing.outputs.performance-score }}% (‚â•60% required)"
          echo "- Accessibility Score: ${{ needs.comprehensive-testing.outputs.accessibility-score }}% (‚â•60% required)"
          echo ""
          echo "Merging staging branch to main for production deployment..."
          
          # Configure git
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          # Fetch all branches
          git fetch origin
          
          # Switch to main branch
          git checkout main
          git pull origin main
          
          # Merge staging branch (prefer staging changes for conflicts)
          git merge staging --no-ff --allow-unrelated-histories --strategy=recursive -X theirs -m "ü§ñ Automated merge: Comprehensive testing passed

          Automated deployment triggered by comprehensive testing results:
          - Security Score: ${{ needs.comprehensive-testing.outputs.security-score }}%
          - Performance Score: ${{ needs.comprehensive-testing.outputs.performance-score }}%
          - Accessibility Score: ${{ needs.comprehensive-testing.outputs.accessibility-score }}%
          
          All deployment criteria met for production deployment."
          
          # Push to main (this will trigger the production deployment)
          git push origin main
          
          echo "‚úÖ Staging branch merged to main successfully"

      - name: üîß Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: üßπ Clean and prepare production files
        run: |
          echo "üßπ Preparing website files for production deployment..."
          
          # Remove any test/debug files that shouldn't be deployed
          find website/ -name "*.test.*" -delete || true
          find website/ -name "*debug*" -delete || true
          find website/ -name "*temp*" -delete || true
          
          # Ensure proper file permissions
          find website/ -type f -name "*.html" -exec chmod 644 {} \;
          find website/ -type f -name "*.css" -exec chmod 644 {} \;
          find website/ -type f -name "*.js" -exec chmod 644 {} \;
          
          echo "‚úÖ Website files prepared for production"

      - name: üöÄ Deploy website to production
        run: |
          echo "üöÄ Deploying website to production environment..."
          
          # Sync website files to production bucket
          aws s3 sync website/ s3://${{ env.PRODUCTION_BUCKET }} \
            --delete \
            --exclude "*.tf" \
            --exclude "*.tfvars" \
            --exclude "*.tfstate*" \
            --exclude "terraform/" \
            --exclude "backup/" \
            --exclude "*.test.*" \
            --exclude "*debug*" \
            --exclude "*temp*" \
            --cache-control "public, max-age=3600" \
            --metadata "deployment=production,commit=${{ github.sha }}"
          
          echo "‚úÖ Website deployed to production S3 bucket"
          
          # Create CloudFront invalidation for production
          PRODUCTION_DISTRIBUTION_ID=$(aws cloudfront list-distributions \
            --query "DistributionList.Items[?Comment=='Robert Consulting Website'].Id" \
            --output text)
          
          if [ -n "$PRODUCTION_DISTRIBUTION_ID" ]; then
            echo "üîÑ Creating CloudFront invalidation for production..."
            aws cloudfront create-invalidation \
              --distribution-id $PRODUCTION_DISTRIBUTION_ID \
              --paths "/*"
            echo "‚úÖ Production CloudFront invalidation created"
          else
            echo "‚ö†Ô∏è Could not find production CloudFront distribution"
          fi

      - name: ‚è≥ Wait for production deployment
        run: |
          echo "‚è≥ Waiting for production deployment to be ready..."
          sleep 30
          
          # Test production site accessibility
          for i in {1..10}; do
            if curl -f -s -I "${{ env.PRODUCTION_URL }}" > /dev/null; then
              echo "‚úÖ Production site is accessible"
              break
            else
              echo "‚è≥ Waiting for production site... (attempt $i/10)"
              sleep 10
            fi
          done

      - name: üîç Production validation
        run: |
          echo "üîç Validating production deployment..."
          
          # Test main page
          STATUS=$(curl -s -o /dev/null -w "%{http_code}" "${{ env.PRODUCTION_URL }}")
          if [ "$STATUS" != "200" ]; then
            echo "‚ùå Production site returned status $STATUS"
            exit 1
          fi
          
          # Test security headers
          HEADERS=$(curl -s -I "${{ env.PRODUCTION_URL }}")
          if ! echo "$HEADERS" | grep -qi "x-frame-options"; then
            echo "‚ùå Missing security headers on production"
            exit 1
          fi
          
          echo "‚úÖ Production deployment validated successfully"

      - name: üìä Automated Production Deployment Summary
        run: |
          echo "## ü§ñ Automated Production Deployment Complete" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ‚úÖ Successfully deployed to production via automated approval" >> $GITHUB_STEP_SUMMARY
          echo "- **Production URL**: ${{ env.PRODUCTION_URL }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Deployed by**: GitHub Actions (Automated)" >> $GITHUB_STEP_SUMMARY
          echo "- **Timestamp**: $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "- **Validation**: ‚úÖ All comprehensive tests passed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üß™ Test Scores That Triggered Auto-Deployment:" >> $GITHUB_STEP_SUMMARY
          echo "- **Security Score**: ${{ needs.comprehensive-testing.outputs.security-score }}% (‚â•80% required)" >> $GITHUB_STEP_SUMMARY
          echo "- **Performance Score**: ${{ needs.comprehensive-testing.outputs.performance-score }}% (‚â•60% required)" >> $GITHUB_STEP_SUMMARY
          echo "- **Accessibility Score**: ${{ needs.comprehensive-testing.outputs.accessibility-score }}% (‚â•60% required)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üéØ Automated Deployment Benefits:" >> $GITHUB_STEP_SUMMARY
          echo "- **Zero manual intervention required**" >> $GITHUB_STEP_SUMMARY
          echo "- **Comprehensive quality assurance**" >> $GITHUB_STEP_SUMMARY
          echo "- **Consistent deployment process**" >> $GITHUB_STEP_SUMMARY
          echo "- **Full audit trail maintained**" >> $GITHUB_STEP_SUMMARY
